
// Структура, хранящая глобальные параметры скрипта
// Используется в качестве пространства имен, разрешающего конфликты 
// между настройками и локальными идентификаторами
Перем мПараметры;
Перем мКонтекстВыполнения; // Временные данные скрипта

Перем юТест; // объект юнит-тестов

Функция Версия() Экспорт
	Возврат "1.0.1.17";
КонецФункции

Функция ПолучитьСписокТестов(ЮнитТестирование) Экспорт
	
	юТест = ЮнитТестирование;
	
	ВсеТесты = Новый Массив;

	ВсеТесты.Добавить("Тест_ДолженЗагрузитьМодули");
	ВсеТесты.Добавить("Тест_ДолженВыгрузитьФайлКонфигурацииИзВновьСозданнойБазы");
	ВсеТесты.Добавить("Тест_ДолженПолучитьМаксимальнуюВерсию83");
	ВсеТесты.Добавить("Тест_ДолженВыполнитьПолнуюВыгрузкуЧерезПараметрыЗапуска");
	ВсеТесты.Добавить("Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации");
	ВсеТесты.Добавить("Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации_Платформа82");
	ВсеТесты.Добавить("Тест_ДолженВыгрузитьМодули");
	ВсеТесты.Добавить("Тест_ДолженРазложитьМодули1СПоПапкамСогласноИерархииМетаданных");
	ВсеТесты.Добавить("Тест_ДолженРазложитьМодули1СПоПапкамСогласноИерархииМетаданных_Платформа82");
	ВсеТесты.Добавить("Тест_ДолженСобратьМодули1СИзПапокСогласноИерархииВОднуЛинейнуюПапку");
	ВсеТесты.Добавить("Тест_ДолженПолучитьТаблицуОписанияВсехИБ");
	ВсеТесты.Добавить("Тест_ДолженПолучитьПутьПлатформы1СПоПутиИБ");
	ВсеТесты.Добавить("Тест_ДолженУбратьОбрамляющиеКавычкиЕслиЕсть");
	ВсеТесты.Добавить("Тест_ДолженПолучитьФайлВерсийХранилища");
	ВсеТесты.Добавить("Тест_ДолженПрочитатьФайлВерсийИзХранилища1С");
	ВсеТесты.Добавить("Тест_ДолженПрочитатьФайлПользователейИзХранилища1С");
	ВсеТесты.Добавить("Тест_ДолженПрочитатьФайлВерсийСИменамиПользователейИзХранилища1С");
	ВсеТесты.Добавить("Тест_ТестДолженПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С");
	ВсеТесты.Добавить("Тест_ТестДолженПоНомеруВерсииРазобратьКонфигурациюИзХранилища1С");
	ВсеТесты.Добавить("Тест_ДолженРазложитьМодули1СпоНомеруВерсииХранилища1С");
	ВсеТесты.Добавить("ТестДолжен_СинхронизироватьХранилищеКонфигурацийСГит");

	Возврат ВсеТесты;
	
КонецФункции

Функция ЗначениеЗаполнено(Значение)
	
	Если Значение = Неопределено Тогда
		Возврат Ложь;
	ИначеЕсли Значение = 0 Тогда
		Возврат Ложь;
	ИначеЕсли ПустаяСтрока(Значение) Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

//////////////////////////////////////////////////////////////////////////////////
// Программный интерфейс
//

Функция ПолучитьПараметрыИнициализации() Экспорт
	
	Если мПараметры = Неопределено Тогда
		мПараметры = Новый Структура;
		мПараметры.Вставить("РабочийКаталог", "");
		мПараметры.Вставить("ПутьКПлатформе83", ПолучитьПутьПлатформы83());
		
	КонецЕсли;
	
	Возврат мПараметры;
	
КонецФункции

Процедура Инициализация() Экспорт
	
	Если мПараметры <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	мКонтекстВыполнения = Новый Структура;
	
	Если ПустаяСтрока(мПараметры.РабочийКаталог) Тогда
		мПараметры.РабочийКаталог = КаталогРабочихФайлов();
	Иначе
		Файл = Новый Файл(мПараметры.РабочийКаталог);
		Если Не Файл.Существует() или Не Файл.ЭтоКаталог() Тогда
			ВызватьИсключение "Рабочий каталог <"+мПараметры.РабочийКаталог+"> не может быть использован";
		КонецЕсли;		
	КонецЕсли;
	
	мПараметры.РабочийКаталог = ДополнитьСлешВПуть(мПараметры.РабочийКаталог);	
	
	ФайлПрограммыРаспаковки = Новый Файл("bin\UnpackV8.exe");
	Если Не ФайлПрограммыРаспаковки.Существует() Тогда
		ВызватьИсключение "Не обнаружен файл программы распаковки: <"+ФайлПрограммыРаспаковки.ПолноеИмя+">";
	КонецЕсли;
	
	ФайлDLL = Новый Файл("bin\zlib1.dll");
	Если НЕ ФайлDLL.Существует() Тогда
		ВызватьИсключение "Не обнаружена библиотека zlib1: <"+ФайлDLL.ПолноеИмя+">";
	КонецЕсли; 
	
	Если ПустаяСтрока(мПараметры.ПутьКПлатформе83) Тогда
		мПараметры.ПутьКПлатформе83 = ПолучитьПутьПлатформы83();
	КонецЕсли;
	
КонецПроцедуры


// Ищет наиболее свежую версию платформы. Работает для 32- и 64-разрядных систем
//
Функция ПолучитьПутьКВерсииПлатформы(версияПлатформы, парамОписаниеОшибки = "") Экспорт
	Если Лев(версияПлатформы, 2) <> "8." Тогда
		ВызватьИсключение "Неверная версия платформы <"+версияПлатформы+">";
	КонецЕсли;	
	
	путьProgramFiles = "C:\Program Files (x86)\";
	файлProgramFiles = Новый Файл(путьProgramFiles);
	Если Не файлProgramFiles.Существует() Тогда
		путьProgramFiles = "C:\Program Files\";
		файлProgramFiles = Новый Файл(путьProgramFiles);
		Проверить(файлProgramFiles.Существует(), "Должен существовать путь к Program Files или Program Files (86)");
	КонецЕсли;
	
	парамОписаниеОшибки = "";
	
	СписокСтрок = РазложитьСтрокуВМассивПодстрок(версияПлатформы, ".", Ложь);
	версия1 = СписокСтрок[0];
	версия2 = СписокСтрок[1];
	
	Если версия2 = "3" Тогда // 8.3
		путьКПлатформе = путьProgramFiles + "1cv8\";
	ИначеЕсли версия2 = "2" Тогда // 8.2
		путьКПлатформе = путьProgramFiles + "1cv82\";	
	ИначеЕсли версия2 = "1" Тогда // 8.1
		путьКПлатформе = путьProgramFiles + "1cv81\";
	Иначе
		ВызватьИсключение "Неверная версия платформы <"+версияПлатформы+">";
	КонецЕсли;
	
	МассивФайлов = НайтиФайлы(путьКПлатформе, версияПлатформы+"*.*");
	Если МассивФайлов.Количество() = 0 Тогда
		парамОписаниеОшибки = "Не найден путь к платформе 1С <"+версияПлатформы+">";
		Возврат "";
	КонецЕсли;
	
	ИменаВерсий = Новый Массив;
	Для Каждого ЭлементМассива Из МассивФайлов Цикл
		правыйСимвол = Прав(ЭлементМассива.Имя,1);
		Если правыйСимвол < "0" или правыйСимвол > "9" Тогда
			Продолжить;
		КонецЕсли;
		ИменаВерсий.Добавить(ЭлементМассива.Имя);
	КонецЦикла;
	
	МаксВерсия = ИменаВерсий[0];
	Для Сч = 1 По ИменаВерсий.Количество()-1 Цикл
		Если МаксВерсия < ИменаВерсий[Сч] Тогда
			МаксВерсия = ИменаВерсий[Сч];
		КонецЕсли;
	КонецЦикла;
	
	нужныйПуть = путьКПлатформе + МаксВерсия + "\bin\1cv8.exe";
	
	Возврат нужныйПуть;
КонецФункции

Функция ПолучитьПутьПлатформы83() Экспорт
	ПутьПлатформы1С_83 = ПолучитьПутьКВерсииПлатформы("8.3");
	ФайлПлатформы = Новый Файл(ПутьПлатформы1С_83);
	Проверить(файлПлатформы.Существует(), "Не найден путь к платформе 1С 8.3 - не существует файл <"+ПутьПлатформы1С_83+">");
	
	Возврат ПутьПлатформы1С_83;
КонецФункции

Функция СоздатьВременныйФайл(Знач Расширение = Неопределено)
	Если Расширение = Неопределено Тогда
		Расширение = "tmp";
	КонецЕсли;
	Если (не ПустаяСтрока(Расширение)) и Лев(Расширение, 1) <> "."  Тогда
		Расширение = "."+Расширение;
	КонецЕсли;	
	
	Префикс = "v83up_";
	БазовоеИмя = КаталогРабочихФайлов()+Префикс;
	резИмя = СоздатьУникальныйФайл(БазовоеИмя);
	
	ЗарегистрироватьВременныйФайл(резИмя);
	
	Возврат резИмя;
КонецФункции

Функция СоздатьУникальныйФайл(Знач БазовоеИмя, Знач Счетчик = 0)

	ФайлБаза = Новый Файл(БазовоеИмя);
	Если Счетчик = 0 Тогда
		ФайлТест = ФайлБаза;
	Иначе
		ФайлТест = Новый Файл(ФайлБаза.Путь + "\" + ФайлБаза.ИмяБезРасширения + Строка(Счетчик) + ФайлБаза.Расширение);
	КонецЕсли;
	
	Если Не ФайлТест.Существует() Тогда
		ЗаписьТекста = Новый ЗаписьТекста(ФайлТест.ПолноеИмя);
		ЗаписьТекста.Закрыть(); // теперь никто не заберет это имя
		Возврат ФайлТест.ПолноеИмя;
	Иначе
		Возврат СоздатьУникальныйФайл(БазовоеИмя, Счетчик + 1);
	КонецЕсли;

КонецФункции

Функция СоздатьУникальноеИмяКаталога(Знач БазовоеИмя, Знач Счетчик = 0)
	
	ФайлБаза = Новый Файл(БазовоеИмя);
	Если Счетчик = 0 Тогда
		ФайлТест = ФайлБаза;
	Иначе
		ФайлТест = Новый Файл(ФайлБаза.Путь + "\" + ФайлБаза.ИмяБезРасширения + Строка(Счетчик) + ФайлБаза.Расширение);
	КонецЕсли;
	
	Если Не ФайлТест.Существует() Тогда
		СоздатьКаталог(ФайлТест.ПолноеИмя);
		Возврат ФайлТест.ПолноеИмя;
	Иначе
		Возврат СоздатьУникальноеИмяКаталога(БазовоеИмя, Счетчик + 1);
	КонецЕсли;
	
КонецФункции

Процедура ЗаписатьОшибкуВЛог(ПутьКФайлуЛога, СтрокаОшибки) Экспорт
	
	Если НЕ ПустаяСтрока(ПутьКФайлуЛога) Тогда
		Попытка
			Запись = Новый ЗаписьТекста(ПутьКФайлуЛога, КодировкаТекста.ANSI);
			Запись.ЗаписатьСтроку(СтрокаОшибки);
			Запись.Закрыть();
		Исключение
			Сообщить("Ошибка записи в лог ошибок "+ОписаниеОшибки());
		КонецПопытки;
	КонецЕсли;
	
КонецПроцедуры

Процедура РазобратьФайлКонфигурации(парамПутьКФайлуКонфигурации, парамПутьККаталогуДляВыгрузки, СтруктураПараметров = Неопределено) Экспорт 
	Строка = "pathToCF;"+парамПутьКФайлуКонфигурации+";pathOut;"+парамПутьККаталогуДляВыгрузки+";decompile;";	
	ОбработатьПараметрыЗапуска(Строка, СтруктураПараметров);
КонецПроцедуры

Процедура СобратьФайлКонфигурации(парамПутьКФайлуКонфигурации, парамПутьККаталогуДляВыгрузки, СтруктураПараметров = Неопределено) Экспорт 
	Строка = "pathToCF;"+парамПутьКФайлуКонфигурации+";pathOut;"+парамПутьККаталогуДляВыгрузки+";compile;";	
	ОбработатьПараметрыЗапуска(Строка, СтруктураПараметров);
КонецПроцедуры

Процедура СинхронизироватьХранилищеСГит(парамПутьФайлуХранилища, парамПутьККаталогуДляВыгрузки) Экспорт	
	Строка = "pathRepo;"+парамПутьФайлуХранилища+";pathOut;"+парамПутьККаталогуДляВыгрузки+";sync1ctogit;";
	ОбработатьПараметрыЗапуска(Строка);
 КонецПроцедуры

Функция РазложитьМодули1СпоНомеруВерсииХранилища1С(ПутьКБазе, версияПлатформыДляБазы, Пользователь, Пароль, ПутьКХранилищу1C, 
		ПользовательХранилища, ПарольХранилища, ПутьКФайлуХранилища1С, НомерВерсииХранилища, КаталогВыгрузки, резКаталогВыгрузкиВсехМодулей83, резПутьКФайлуКонфигурации) Экспорт
	лНачало = ТекущаяДата();
	ВывестиОтладочноеСообщение("Начало "+лНачало);
	
	Инициализация();
	
	резПутьКФайлуКонфигурации = "";
	Если НЕ ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С(ПутьКБазе, версияПлатформыДляБазы, Пользователь, Пароль, ПутьКХранилищу1C, 
		ПользовательХранилища, ПарольХранилища, ПутьКФайлуХранилища1С, НомерВерсииХранилища, резПутьКФайлуКонфигурации) Тогда
			ВывестиОтладочноеСообщение("Завершение "+ТекущаяДата());
			Возврат Ложь;
	КонецЕсли;
	//Параметры.Вставить("ПутьКФайлуКонфигурации", резПутьКФайлуКонфигурации);
	резИмяКаталогаБазы = "";
	Если НЕ РазложитьКонфигурацию1СПоПапкамСогласноИерархииМетаданных("", "", резПутьКФайлуКонфигурации, КаталогВыгрузки, резИмяКаталогаБазы)  Тогда

		ВывестиОтладочноеСообщение("Завершение "+ТекущаяДата());
		Возврат Ложь;
	КонецЕсли;

	
	УдалитьВременныеФайлыВПопытке(резПутьКФайлуКонфигурации);

	
	лОкончание = ТекущаяДата();
	затратилиВремениВМинутах = (лОкончание - лНачало) / 60;
	ВывестиОтладочноеСообщение("Завершение "+лОкончание+ ", Общее время: "+затратилиВремениВМинутах+" мин.");
	
	Возврат Истина;

КонецФункции

Функция Распаковка(ФайлРаспаковки,КаталогРаспаковки)
	ФайлДляРаспаковки=Новый файл(ФайлРаспаковки);
	Если КаталогРаспаковки="" тогда
		//ИнтересующийКаталог=Новый файл(_КаталогВременныхФайлов()+ФайлДляРаспаковки.Имя+".und");
		//Если  ИнтересующийКаталог.Существует() тогда
		//	ГСЧ = Новый ГенераторСлучайныхЧисел(ТекущаяДата()-Дата('00010101'));
		//	КаталогРаспаковки=_КаталогВременныхФайлов()+ФайлДляРаспаковки.Имя+Строка(ГСЧ.СлучайноеЧисло(0, 1000)) +".und";
		//Иначе
		//	КаталогРаспаковки=_КаталогВременныхФайлов()+ФайлДляРаспаковки.Имя+".und";
		//КонецЕсли;
		КаталогРаспаковки = _КаталогВременныхФайлов()+ (Новый УникальныйИдентификатор()) +".und";
	ИначеЕсли	НайтиФайлы(КаталогРаспаковки,"*.*").Количество()>0 тогда
		//Предупреждение("Указанный каталог не пустой. В каталоге будет создан подкаталог"+Символы.ПС+КаталогРаспаковки+"\"+ФайлДляРаспаковки.Имя+".und");
		//КаталогРаспаковки=КаталогРаспаковки+"\"+ФайлДляРаспаковки.Имя+".und";
	КонецЕсли;
	
	//Если ФайлПрограммыРаспаковки=Неопределено или НЕ ФайлПрограммыРаспаковки.Существует() тогда
	//	Инициализация();
	//КонецЕсли;
	Если НЕ ФайлПрограммыРаспаковки.Существует() тогда
		ВывестиОшибку("Не существует файл программы распаковки <"+ФайлПрограммыРаспаковки.ПолноеИмя+">");
		Возврат Ложь;
	КонецЕсли;
	
	// распакуем файл
	//Состояние("Чтение файла...");
	СтрокаЗапуска = """"+ФайлПрограммыРаспаковки.ПолноеИмя+""" -parse """+ФайлДляРаспаковки.ПолноеИмя+""" """+КаталогРаспаковки+"""";
	//ВывестиОтладочноеСообщение(СтрокаЗапуска);
	
	WshShell.Run(СтрокаЗапуска, 0, Истина); // TODO если будут глюки, заменить на вызов ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения
	Возврат Истина;
КонецФункции

Функция Упаковка(ФайлРезультат,Каталог)
	каталогДляУпаковки=Новый файл(Каталог);
	
	//Если ФайлПрограммыРаспаковки=Неопределено или НЕ ФайлПрограммыРаспаковки.Существует() тогда
	//	Инициализация();
	//КонецЕсли;
	Если НЕ ФайлПрограммыРаспаковки.Существует() тогда
		ВывестиОшибку("Не существует файл программы распаковки <"+ФайлПрограммыРаспаковки.ПолноеИмя+">");
		Возврат Ложь;
	КонецЕсли;
	
	СтрокаЗапуска = """"+ФайлПрограммыРаспаковки.ПолноеИмя+""" -build """+каталогДляУпаковки.ПолноеИмя+""" """+ФайлРезультат+"""";
	ВывестиОтладочноеСообщение(СтрокаЗапуска);
	
	WshShell.Run(СтрокаЗапуска, 0, Истина);
	
	Возврат Истина;
КонецФункции

Функция ПолучитьТаблицуВерсийИзФайлаХранилища1С(ПутьКФайлуХранилища1С, резПутьКХМЛФайлуВерсийХранилища1С, резПутьКХМЛФайлуПользователейХранилища1С, резТаблицаИсторииХранилища, резТаблицаАвторовХранилища) Экспорт
	резТаблицаИсторииХранилища = Неопределено;
	
	//ПутьКХМЛФайлуВерсийХранилища1С = "";
	//ПутьКХМЛФайлуПользователейХранилища1С = "";
	//	//ПутьКТаблицамИзФайлаХранилища1С = "";
	
	Если Не ВыгрузитьФайлВерсийИзФайлаХранилища1С(ПутьКФайлуХранилища1С, резПутьКХМЛФайлуВерсийХранилища1С, резПутьКХМЛФайлуПользователейХранилища1С) Тогда
		ВывестиОшибку("Не удалось получить файл версий из хранилища 1С - ПолучитьТаблицуВерсийИзФайлаХранилища1С");
		Возврат Ложь;
	КонецЕсли; 
		
	//_тест_СтруктураПараметров.Вставить("ПутьКХМЛФайлуВерсийХранилища1С", ПутьКХМЛФайлуВерсийХранилища1С);
	//_тест_СтруктураПараметров.Вставить("ПутьКХМЛФайлуПользователейХранилища1С", ПутьКХМЛФайлуПользователейХранилища1С);
	
	лПутьФайлаВерсий = резПутьКХМЛФайлуВерсийХранилища1С; //СтруктураПараметров.ПутьКХМЛФайлуВерсийХранилища1С;
	
	таблицаИсторииХранилища = Неопределено;
	Если НЕ ПрочитатьФайлВерсий(лПутьФайлаВерсий, таблицаИсторииХранилища) Тогда
		ВывестиОшибку("Не удалось получить таблицу версий из хранилища 1С - ПолучитьТаблицуВерсийИзФайлаХранилища1С");
		Возврат Ложь;
	КонецЕсли;
	
	лПутьФайлаПользователей = резПутьКХМЛФайлуПользователейХранилища1С; //СтруктураПараметров.ПутьКХМЛФайлуПользователейХранилища1С;

	таблицаПользователейХранилища = Неопределено;
	Если НЕ ПрочитатьФайлПользователей(лПутьФайлаПользователей, таблицаПользователейХранилища) Тогда
		ВывестиОшибку("Не удалось получить таблицу пользователей из хранилища 1С - ПолучитьТаблицуВерсийИзФайлаХранилища1С");
		Возврат Ложь;
	КонецЕсли; 
	
	таблицаПользователейХранилища.Индексы.Добавить("ГУИД_Автора");
	резТаблицаАвторовХранилища = таблицаПользователейХранилища; //СтруктураПараметров.Вставить("ТаблицаАвторовХранилища", таблицаПользователейХранилища);
	
	успешно = Истина;
	Для каждого строка Из таблицаИсторииХранилища Цикл
		строкаПользователя = таблицаПользователейХранилища.Найти(строка.ГУИД_Автора, "ГУИД_Автора");
		Если строкаПользователя = Неопределено Тогда
			ВывестиОшибку("Не удалось найти автора коммита из хранилища 1С по номер версии <"+строка.НомерВерсии+">, комментарий <"+строка.Комментарий+">, ГУИД-у <"+строка.ГУИД_Автора+"> - ПолучитьТаблицуВерсийИзФайлаХранилища1С");
			//успешно = Ложь;//Удалено: Не все авторы могут коммитеть в хранилище Сосна Евгений <shenja@sosna.zp.ua> 26.10.2013
		Иначе
			строка.Автор = строкаПользователя.Автор;
		КонецЕсли; 
	КонецЦикла; 
	резТаблицаИсторииХранилища = таблицаИсторииХранилища;//СтруктураПараметров.Вставить("ТаблицаИсторииХранилища", таблицаИсторииХранилища);
	
	Возврат успешно;
КонецФункции


Функция ПолучитьТаблицуВерсийИзФайлаХранилищаГит(КаталогВыгрузки, ПутьКФайлуХранилища1С, резТаблицаИсторииХранилища, резТаблицаАвторовХранилища, резТаблицаПользователейГит, резТекущаяВерсия) Экспорт
	
	Сообщить("Процедура ПолучитьТаблицуВерсийИзФайлаХранилищаГит временно отключена");
	Возврат Истина;
	
	резПутьКХМЛФайлуВерсийХранилища1С = "";
	резПутьКХМЛФайлуПользователейХранилища1С = "";
	Если НЕ ПолучитьТаблицуВерсийИзФайлаХранилища1С(ПутьКФайлуХранилища1С, резПутьКХМЛФайлуВерсийХранилища1С, резПутьКХМЛФайлуПользователейХранилища1С, резТаблицаИсторииХранилища, резТаблицаАвторовХранилища) Тогда //
		ВывестиОшибку("Не удалось получить файл версий и таблицу авторов из хранилища 1С - Синхронизация хранилища");
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ПроверитьСуществованиеФайлаКаталога(КаталогВыгрузки, "путь к папке синхронизации") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	
	лПутьФайлаВерсий = КаталогВыгрузки+"VERSION";
	
	ТекущаяВерсия = "";
	Попытка
		Если НЕ ПрочитатьФайлВерсийГит(лПутьФайлаВерсий, ТекущаяВерсия) Тогда
			ТекущаяВерсия = 0;
		КонецЕсли;
	Исключение
		Если ОписаниеОшибки() = "Файл с версией ГИТ не существует - Синхронизация хранилища" Тогда
			Если НЕ ЗаписатьФайлВерсийГит(лПутьФайлаВерсий, 0) Тогда
				Возврат Ложь;
			КонецЕсли;
			
			ТекущаяВерсия = 0;
		КонецЕсли;
	КонецПопытки;
	
	Попытка
		ТекущаяВерсия=Число(ТекущаяВерсия);
	Исключение
		ТекущаяВерсия = 0;
	КонецПопытки;
	
	лПутьФайлаПользователей = КаталогВыгрузки+"\AUTHORS";
	
	таблицаПользователейГит = Неопределено;
	//Изменено: Сосна Евгений <shenja@sosna.zp.ua> 26.10.2013
	//Если НЕ ПрочитатьФайлПользователей(лПутьФайлаПользователей, таблицаПользователейГит) Тогда
	//---- Заменено на: ----
	Если НЕ ПрочитатьФайлАвторовГит(лПутьФайлаПользователей, таблицаПользователейГит) Тогда
	/// Сосна Евгений <shenja@sosna.zp.ua> 26.10.2013

		ВывестиОшибку("Не удалось получить таблицу пользователей из гит 1С - ПолучитьТаблицуВерсийИзФайлаХранилищаГит");
		Возврат Ложь;
	КонецЕсли; 
	
	таблицаПользователейГит.Индексы.Добавить("ГУИД_Автора");
	
	резТаблицаПользователейГит = таблицаПользователейГит; //СтруктураПараметров.Вставить("ТаблицаАвторовГит", таблицаПользователейГит);
	резТекущаяВерсия = ТекущаяВерсия; //СтруктураПараметров.Вставить("ТекущаяВерсия", ТекущаяВерсия);
	
	таблицаАвторовХранилища = резТаблицаАвторовХранилища; //СтруктураПараметров.ТаблицаАвторовХранилища;
	таблицаИсторииХранилища = резТаблицаИсторииХранилища; //СтруктураПараметров.ТаблицаИсторииХранилища;
	успешно = Истина;
	Для каждого строка Из таблицаАвторовХранилища Цикл
		строкаПользователя = таблицаПользователейГит.Найти(строка.ГУИД_Автора, "ГУИД_Автора");
		Если строкаПользователя = Неопределено Тогда
			ВывестиОшибку("Не удалось найти автора из хранилища 1С  <"+строка.Автор+">, ГУИД-у <"+строка.ГУИД_Автора+"> - ПолучитьТаблицуВерсийИзФайлаХранилища1С");
			//успешно = Ложь;
		Иначе
			строка.ПредставлениеАвтора = строкаПользователя.ПредставлениеАвтора;
			СтруктураОтбора = Новый Структура;
			СтруктураОтбора.Вставить("ГУИД_Автора", строка.ГУИД_Автора);
			
			НайденныеСтроки = ТаблицаИсторииХранилища.НайтиСтроки(СтруктураОтбора);
			Если НайденныеСтроки.Количество() > 0 Тогда
				Для каждого элементМассива Из НайденныеСтроки Цикл
					элементМассива.ПредставлениеАвтора = строкаПользователя.ПредставлениеАвтора;
				КонецЦикла;
			КонецЕсли; 
			
		КонецЕсли; 
	КонецЦикла; 
		
	Возврат успешно;
КонецФункции

Функция ВыгрузитьФайлВерсийИзФайлаХранилища1С(ПутьКФайлуХранилища1С, резПутьКХМЛФайлуВерсийХранилища1С, резПутьКХМЛФайлуПользователейХранилища1С, резПутьКТаблицамИзФайлаХранилища1С = Неопределено) //Экспорт
	//Если Не ЗначениеЗаполнено(СтруктураПараметров) Тогда
	//	ВывестиОшибку("ВыгрузитьФайлВерсийИзФайлаХранилища1С - Не заданы параметры!");
	//	Возврат Ложь;
	//КонецЕсли; 
	Если НЕ ПроверитьСуществованиеФайлаКаталога(ПутьКФайлуХранилища1С, "путь к файлу хранилища 1С") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ФайлTool1C = Новый Файл("bin\Tool_1CD.exe");
	путьTool_1CD = ФайлTool1C.ПолноеИмя;
	
	лПутьКТаблицамИзФайлаХранилища1С = _ПолучитьИмяВременногоФайла()+"\";
	СоздатьКаталог(лПутьКТаблицамИзФайлаХранилища1С); //TODO УДАЛИТЬ временный каталог
	ЗарегистрироватьВременныйФайл(лПутьКТаблицамИзФайлаХранилища1С);
	
	резПутьКТаблицамИзФайлаХранилища1С = лПутьКТаблицамИзФайлаХранилища1С; //СтруктураПараметров.Вставить("ПутьКТаблицамИзФайлаХранилища1С", лПутьКТаблицамИзФайлаХранилища1С);
	
	лПутьКИсторииХранилища = лПутьКТаблицамИзФайлаХранилища1С + "versions.xml";
	резПутьКХМЛФайлуВерсийХранилища1С = лПутьКИсторииХранилища;
	
	лПутьКФайлуПользователейХранилища = лПутьКТаблицамИзФайлаХранилища1С + "users.xml";
	резПутьКХМЛФайлуПользователейХранилища1С = лПутьКФайлуПользователейХранилища;
	
		//лФайлВерсииХранилища = Новый Файл(лПутьКИсторииХранилища);
		//Если лФайлВерсииХранилища.Существует() Тогда
		//	УдалитьФайлы(лПутьКИсторииХранилища);
		//КонецЕсли; 
	
	СтрокаЗапуска = """"+путьTool_1CD+""" " + ПутьКФайлуХранилища1С + " -q -ne -ex " + лПутьКТаблицамИзФайлаХранилища1С + " VERSIONS;USERS";
			//СтрокаЗапуска = """"+путьTool_1CD+""" """ + СтруктураПараметров.ПутьКФайлуХранилища1С + """ -q -ne -ex """ + лПутьКТаблицамИзФайлаХранилища1С + """ VERSIONS";
			//СтрокаЗапуска = """"+путьTool_1CD+""" 1cv8ddb.1CD -ex . VERSIONS -ne -q ";
	ВывестиОтладочноеСообщение(СтрокаЗапуска);
	
	WshShell.CurrentDirectory = лПутьКТаблицамИзФайлаХранилища1С;
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(СтрокаЗапуска, лПутьКТаблицамИзФайлаХранилища1С); //так будут ошибки WshShell.Run(СтрокаЗапуска, 7, Истина);
	
	WshShell.CurrentDirectory = КаталогВременныхФайлов(); // если у WshShell не изменить текущий каталог, этот каталог нельзя будет удалить
	
	Если НЕ ПроверитьСуществованиеФайлаКаталога(лПутьКТаблицамИзФайлаХранилища1С, "путь к файлу истории хранилища 1С") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

Функция ПрочитатьФайлПользователей(парамПутьФайлаПользователей, таблицаПользователейХранилища = Неопределено)
	// Если НЕ ЗначениеЗаполнено(парамПутьФайлаПользователей) Тогда
		// таблицаПользователейХранилища = Неопределено;
		// Возврат Ложь;
	// КонецЕсли;
	
	// Пользователи.Очистить();
	
	// ЧтениеXML = Новый ЧтениеXML;
	// ЧтениеXML.ОткрытьФайл(парамПутьФайлаПользователей);
	
	// Пока ЧтениеXML.Прочитать() Цикл 
		
		// Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента 
			// И ЧтениеXML.Имя = "Record" Тогда
			
			// НоваяСтрока = Пользователи.Добавить();
			// Пока ЧтениеXML.Прочитать() Цикл
				// Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					// Если ЧтениеXML.Имя="USERID" Тогда
						// НоваяСтрока.ГУИД_Автора = ПолучитьТекст(ЧтениеXML);
					// КонецЕсли;
					// Если ЧтениеXML.Имя="NAME" Тогда
						// НоваяСтрока.Автор = ПолучитьТекст(ЧтениеXML);
					// КонецЕсли;
				// КонецЕсли;
				
				// Если ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента И ЧтениеXML.Имя = "Record" Тогда
					// Прервать;	
				// КонецЕсли;
			
			// КонецЦикла;	
				
		// КонецЕсли;
	
	// КонецЦикла;
	
	// таблицаПользователейХранилища = Пользователи.Выгрузить();

	Возврат Истина;
КонецФункции
 
Функция ПрочитатьФайлВерсий(парамПутьКФайлуВерсий, таблицаИсторииХранилища = Неопределено) //Экспорт
	// Если НЕ ЗначениеЗаполнено(парамПутьКФайлуВерсий) Тогда
		// таблицаИсторииХранилища = Неопределено;
		// Возврат Ложь;
	// КонецЕсли;
	
	// История.Очистить();
	
	// ЧтениеXML = Новый ЧтениеXML;
	// ЧтениеXML.ОткрытьФайл(парамПутьКФайлуВерсий);
	
	// Пока ЧтениеXML.Прочитать() Цикл 
		
		// Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента 
			// И ЧтениеXML.Имя = "Record" Тогда
			
			// НоваяСтрока = История.Добавить();
			// Пока ЧтениеXML.Прочитать() Цикл
				// Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					// Если ЧтениеXML.Имя="VERNUM" Тогда
						// НоваяСтрока.НомерВерсии = Число(ПолучитьТекст(ЧтениеXML));
					// КонецЕсли;
					// Если ЧтениеXML.Имя="USERID" Тогда
						// НоваяСтрока.ГУИД_Автора = ПолучитьТекст(ЧтениеXML); //Автор
					// КонецЕсли;
					// Если ЧтениеXML.Имя="CODE" Тогда
						// НоваяСтрока.Тэг = ПолучитьТекст(ЧтениеXML);
					// КонецЕсли;
					// Если ЧтениеXML.Имя="VERDATE" Тогда
						// Дата = ПолучитьТекст(ЧтениеXML);
						// Дата = СтрЗаменить(СтрЗаменить(Дата, "-", ""), ":", "");
						// Дата = СтрЗаменить(Дата, "T", "");
						// Дата = Дата(Дата);
						// НоваяСтрока.Дата = Дата;
					// КонецЕсли;
					
					// Если ЧтениеXML.Имя="COMMENT"  Тогда
						// НоваяСтрока.Комментарий = ПолучитьТекст(ЧтениеXML);
					// КонецЕсли;
					
					// Если Ложь 
						// ИЛИ 
						// ( Ложь
							// ИЛИ ЧтениеXML.Имя = "SNAPSHOTMAKER"  
							// ИЛИ ЧтениеXML.Имя = "SNAPSHOTCRC"
							// ИЛИ ЧтениеXML.Имя = "PVERSION"
							// ИЛИ ЧтениеXML.Имя = "CVERSION"
 
						// )	Тогда
						// Текст = ПолучитьТекст(ЧтениеXML);
					// КонецЕсли;
					
					
					
				// КонецЕсли;
				
				// Если ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента И ЧтениеXML.Имя = "Record" Тогда
					// Прервать;	
				// КонецЕсли;
			
			// КонецЦикла;	
				
		// КонецЕсли;
	
	// КонецЦикла;

	// таблицаИсторииХранилища = История.Выгрузить();
	// таблицаИсторииХранилища.Сортировать("НомерВерсии");
	
	// Возврат Истина;
КонецФункции

Функция ПрочитатьФайлВерсийГит(парамПутьКФайлуВерсий, Версия = "", ЗаписыватьПустой = Ложь)
	// Перем лРезультат;
	
	// лРезультат = Ложь;
	// Если НЕ ЗначениеЗаполнено(парамПутьКФайлуВерсий) Тогда
		
		// Версия = "";
		// Возврат лРезультат;
	// КонецЕсли;
	
	// лФайл = Новый Файл(парамПутьКФайлуВерсий);
	// Проверить(лФайл.Существует(), "Файл с версией ГИТ не существует - Синхронизация хранилища");
	
	
	// ЧтениеXML = Новый ЧтениеXML;
	// ЧтениеXML.ОткрытьФайл(парамПутьКФайлуВерсий);
	
	// Пока ЧтениеXML.Прочитать() Цикл 
	
		// Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ЧтениеXML.Имя = "VERSION" Тогда 
			// ВывестиОтладочноеСообщение(НСтр("ru = '"+ЧтениеXML.Имя+" {'"));
			// Проверить(ЧтениеXML.Прочитать(), "Чтение файла версий, у элемента Version нет текста - Синхронизация хранилища");
			// Проверить(ЧтениеXML.ТипУзла = ТипУзлаXML.Текст, "Чтение файла версий, у элемента Version нет текста - Синхронизация хранилища");
			// Версия = ЧтениеXML.Значение;
			// лРезультат = Истина;
			// Прервать;
		// КонецЕсли;
		
	// КонецЦикла;
	
	// ЧтениеXML.Закрыть();
	
	// Возврат лРезультат;
	
КонецФункции

Функция ЗаписатьФайлВерсийГит(парамПутьКФайлуВерсий, Версия =  "") 
	
	Перем лРезультат;
	
	лРезультат = Истина;
	
	ЗаписьХМL = Новый ЗаписьXML;
	ЗаписьХМL.Отступ = Истина;
	
	ЗаписьХМL.ОткрытьФайл(парамПутьКФайлуВерсий);
	//ЗаписьXML.УстановитьСтроку("<СтрокаXML>");
	
	ЗаписьХМL.ЗаписатьОбъявлениеXML();		
	
	ЗаписьХМL.ЗаписатьНачалоЭлемента("VERSION");
	ЗаписьХМL.ЗаписатьТекст(XMLСтрока(Версия));
	ЗаписьХМL.ЗаписатьКонецЭлемента(); // <КорневойЭлемент>
		
	Попытка
		ЗаписьХМL.Закрыть();
	Исключение
		ВывестиОшибку(ОписаниеОшибки());// ОВСЯНКИН - НСтр("ru = '"+ОписаниеОшибки()+"'")); //, СтатусСообщения.Внимание);
		лРезультат = Ложь;
	КонецПопытки;
	
	
	Возврат лРезультат;
	
КонецФункции

Функция ПрочитатьФайлАвторовГит(парамПутьКФайлуАвторов, ТаблицаПользователей =  Неопределено)
	// Перем лРезультат;
	
	// лРезультат = Ложь;
	// Если НЕ ЗначениеЗаполнено(парамПутьКФайлуАвторов) Тогда
		// ТаблицаПользователей = Неопределено;
		// Возврат лРезультат;
	// КонецЕсли;
	
	// лФайл = Новый Файл(парамПутьКФайлуАвторов);
	// Проверить(лФайл.Существует(), "Файл с авторов ГИТ не существует - Синхронизация хранилища");
	
	// Пользователи.Очистить();
	
	// ТекстовыйФайл = Новый ТекстовыйДокумент;
	// Попытка	
		// ТекстовыйФайл.Прочитать(парамПутьКФайлуАвторов, КодировкаТекста.UTF8);
		
		// Для НомерСтроки = 1 По ТекстовыйФайл.КоличествоСтрок() Цикл 		
			// СтрокаФайла = ТекстовыйФайл.ПолучитьСтроку(НомерСтроки);
			// Индекс = Найти(СтрокаФайла, ";");
			// Если Индекс>0 Тогда
				
				// ГУИД = Лев(СтрокаФайла, Индекс-1);
				// АвторПредставление = СтрЗаменить(СтрокаФайла, ГУИД+";", "");
				
				// НоваяСтрока = Пользователи.Добавить();
				// НоваяСтрока.ПредставлениеАвтора = АвторПредставление;
				// НоваяСтрока.ГУИД_Автора = ГУИД;
			// КонецЕсли;
		// КонецЦикла;
		
		// лРезультат = Истина;
	// Исключение
		// лРезультат = Ложь;
	    // ВывестиОшибку(НСтр("ru = '"+ОписаниеОшибки()+"'")); //, СтатусСообщения.Внимание);
	// КонецПопытки;
	
	// ТаблицаПользователей = Пользователи.Выгрузить();
	
	// Возврат лРезультат;
	
КонецФункции

Функция ЗаписатьФайлАвторовГит(парамПутьКФайлуАвторов, ТаблицаПользователей)
	// Перем лРезультат;
	
	// лРезультат = Истина;
	
	// ТекстовыйФайл = Новый ТекстовыйДокумент;
	
	// Если ТипЗнч(ТаблицаПользователей) <> Тип("ТаблицаЗначений") Тогда
		
		// Возврат Ложь;
	// КонецЕсли;
	
	// Для каждого ЭлементСтроки Из ТаблицаПользователей Цикл
		// Если НЕ ПустаяСтрока(ЭлементСтроки.ПредставлениеАвтора) Тогда
			// ТекстовыйФайл.ДобавитьСтроку(""+ЭлементСтроки.ГУИД_Автора + ";"+ЭлементСтроки.ПредставлениеАвтора);
		// КонецЕсли;
	// КонецЦикла;
		
	// Попытка
		// ТекстовыйФайл.Записать(парамПутьКФайлуАвторов, КодировкаТекста.UTF8);	
	// Исключение
	    // ВывестиОшибку(НСтр("ru = '"+ОписаниеОшибки()+"'")); //, СтатусСообщения.Внимание);
		// лРезультат = Ложь;
	// КонецПопытки;
	
	// Возврат лРезультат;
	
КонецФункции


Функция ПолучитьТекст(ЧтениеXML)
	// Результат = "";
	// Пока ЧтениеXML.Прочитать()	Цикл
		
		// Если ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			// Результат = ЧтениеXML.Значение;
		// КонецЕсли;
		// Если ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			// Прервать;
		// КонецЕсли;
	// КонецЦикла;  
	
	// Возврат Результат;
	
КонецФункции

Функция ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1СИзБазыХранилища(ПутьКФайлуХранилища1С, НомерВерсииХранилища, резПутьКФайлуКонфигурации) Экспорт
	
	Перем ИмяФайлаВыгрузкиКаталог, ПутьКБазе;
	
	резПутьКФайлуКонфигурации = "";
	
	Инициализация();
	
	//#Если НЕ Клиент И НЕ Сервер Тогда
	//Если Ложь Тогда
	//	СтруктураПараметров = Новый Структура; //Справочники.Конфигурации.СоздатьЭлемент();
	//КонецЕсли;
	//#КонецЕсли
	
	//Если ТипЗнч(СтруктураПараметров) <> Тип("Структура") Тогда
	//	ВывестиОшибку("Неправильный параметр");
	//	Возврат Ложь;
	//КонецЕсли;
	
	лИмяФайлаВыгрузкиКаталог = ПолучитьВременноеИмяКаталога(); //СтруктураПараметров.ПутьКДанным;
	//СоздатьКаталог(лИмяФайлаВыгрузкиКаталог);
	
	путьTool_1CD = "bin\Tool_1CD.exe";//КаталогВременныхФайлов()+"Tool_1CD." + (Новый УникальныйИдентификатор()) + ".exe";
	
	лПутьФайлаВыгрузки = лИмяФайлаВыгрузкиКаталог+"\v"+Строка(НомерВерсииХранилища) +".cf";// ОВСЯНКИН - Формат(НомерВерсииХранилища, "ЧЦ=10; ЧДЦ=0; ЧН=; ЧГ=0")+".cf";
	// ОВСЯНКИН - функция формат заменена
	СтрокаЗапуска = """"+путьTool_1CD+""" """ + ПутьКФайлуХранилища1С + """ -q -ne -drc " + Строка(НомерВерсииХранилища) +" """ + лПутьФайлаВыгрузки +"""";
		//СтрокаЗапуска = """"+путьTool_1CD+""" """ + ПутьКФайлуХранилища1С + """ -q -ne -drc " + Формат(НомерВерсииХранилища, "ЧЦ=10; ЧДЦ=0; ЧН=; ЧГ=0") +" """ + лИмяФайлаВыгрузкиКаталог +"""";
	ВывестиОтладочноеСообщение(СтрокаЗапуска);
	
	WshShell.CurrentDirectory = лИмяФайлаВыгрузкиКаталог;
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(СтрокаЗапуска, лИмяФайлаВыгрузкиКаталог); //так будут ошибки WshShell.Run(СтрокаЗапуска, 7, Истина);
	
	WshShell.CurrentDirectory = КаталогВременныхФайлов(); // если у WshShell не изменить текущий каталог, этот каталог нельзя будет удалить
	
	ВыбФайл = Новый Файл(лПутьФайлаВыгрузки);	
	
	успешно = ВыбФайл.Существует();
	Если успешно Тогда
		резПутьКФайлуКонфигурации = ВыбФайл.ПолноеИмя; //СтруктураПараметров.Вставить("ПутьКФайлуКонфигурации", ВыбФайл.ПолноеИмя);
	Иначе 
		ВывестиОшибку("Не удалось получить файл конфигурации по версии <"+НомерВерсииХранилища+"> из файла хранилища <"+ПутьКФайлуХранилища1С+">");
	КонецЕсли;
	//ВыбФайл = Неопределено;
	
	Возврат успешно;		
КонецФункции


Функция ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С(ПутьКБазе, версияПлатформыДляБазы, Пользователь, Пароль, ПутьКХранилищу1C, ПользовательХранилища, ПарольХранилища, 
		ПутьКФайлуХранилища1С, НомерВерсииХранилища, резПутьКФайлуКонфигурации) Экспорт
	
	Перем ИмяФайлаВыгрузкиКаталог, лПутьКБазе;
	
	резПутьКФайлуКонфигурации = "";
	
			//Если ПустаяСтрока(ПутьКБазе) Тогда
			//	СоздатьПустуюБазу("", ПутьКБазе);
			//КонецЕсли;
	
	Инициализация();
	
		
	ФайлХранилища = Новый Файл(ПутьКФайлуХранилища1С);
	Если ФайлХранилища.Существует() И ФайлХранилища.ЭтоФайл() И Найти(ВРег(ФайлХранилища.Расширение), "1CD") > 0 Тогда
		
		успешно = ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1СИзБазыХранилища(ПутьКФайлуХранилища1С, НомерВерсииХранилища, резПутьКФайлуКонфигурации);
		
		Возврат успешно;
	КонецЕсли;
	
	
	ИмяФайлаВыгрузкиКаталог = ПолучитьВременноеИмяКаталога(); //СтруктураПараметров.ПутьКДанным;
		//СоздатьКаталог(ИмяФайлаВыгрузкиКаталог);

	ИмяФайлаКонфигурации = ИмяФайлаВыгрузкиКаталог + "1cv8_"
			+ "_" + Строка(НомерВерсииХранилища) + ".cf";
			
	ВыбФайл = Новый Файл(ИмяФайлаКонфигурации);
	Если ВыбФайл.Существует() Тогда
		УдалитьФайлы(ИмяФайлаКонфигурации);
			////Может быть это он и есть, зачем еще раз выгружать. 
			////
			////ОперацииНадХранилищем.Сообщение(""+ИмяФайлаКонфигурации, "Уже существует!");
			//СтруктураПараметров.Вставить("ИмяФайлаВыгрузкиКонфигурации",ИмяФайлаКонфигурации);
			//ИмяФайлаВыгрузкиКонфигурации = ИмяФайлаКонфигурации;
			//
			////ОперацииНадХранилищем.Сообщение("","Выгрузка завершенна");
			//
			//Возврат Ложь;	
		
	КонецЕсли;
	
	ВыбФайл = Неопределено;

	Если ПустаяСтрока(ПутьКБазе) Тогда
		СоздатьПустуюБазу("", ПутьКБазе);
	КонецЕсли;
	
	// ОВСЯНКИН - разобраться и переделать. СтрПолучитьСтроку явно не обязателен здесь
	// СписокСтрок = СтрЗаменить(ПутьКБазе, """", Символы.ВК);
	// Если Найти(НРег(ПутьКБазе),"file") Тогда
		// лПутьКБазе = " /F """ + СтрПолучитьСтроку(СписокСтрок, 2) + """";
	// Иначе
		// лПутьКБазе = " /S """ + СтрПолучитьСтроку(СписокСтрок, 2) + "\" + СтрПолучитьСтроку(СписокСтрок,4) + """";
	// КонецЕсли;
	
	Если ПустаяСтрока(версияПлатформыДляБазы) Тогда
		путьКПлатформе1С = ПолучитьПутьПлатформы1СПоПутиИБ(ПутьКБазе); //Константы.ПутьКПлатформе1с.Получить()
	Иначе
		путьКПлатформе1С = ПравильныйПутьКПлатформеПоВерсииПлатформы(версияПлатформыДляБазы); //Константы.ПутьКПлатформе1с.Получить()
	КонецЕсли; 
	
	СтрокаЛогина = ПолучитьСтрокуЛогинаКомандыЗапуска1С(Пользователь, Пароль);
	
	АппЛог = ПолучитьВременноеИмяФайлаЛога();
	//АппЛог2 = ПолучитьВременноеИмяФайлаЛога();
	
	СтрокаХранилища = " /ConfigurationRepositoryF """+ПутьКХранилищу1C+"""";
	
	Если ЗначениеЗаполнено(ПользовательХранилища) Тогда
		СтрокаЛогинаХранилища = " /ConfigurationRepositoryN "+ПользовательХранилища 
							+ " /ConfigurationRepositoryP """+ПарольХранилища+"""";
	КонецЕсли;
	
	// выполняем
	Команда = """"+путьКПлатформе1С+""""
			+ " DESIGNER" + лПутьКБазе
			+ СтрокаЛогина
			+ СтрокаХранилища 
			+ СтрокаЛогинаХранилища
			+ " /ConfigurationRepositoryDumpCfg """ + ИмяФайлаКонфигурации+""""
			+ " -v "+Строка(НомерВерсииХранилища)
			//+ " /Out "+АппЛог2 // todo Конфигуратор не работает с OUT в режиме ConfigurationRepositoryDumpCfg
			+ " /DumpResult " +АппЛог//+ - унарный плюс oscript не поддерживает. Вообще, здесь, вероятно, ошибка
			+ " /Lru"
			"""";
			//+ " /Out"""+АппЛог+"""";
	ВывестиОтладочноеСообщение("Команда <"+Команда+">");
		//ОперацииНадХранилищем.Сообщение(Команда,"Файл когфигурации: "+ИмяФайлаКонфигурации);
		//Состояние("Выполняется выгрузка конфигурации...");
	
	
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда); //(Команда,,Истина,,Истина);
	
		//ПоследняяВерсияХранилища = СтруктураПараметров.ПоследняяВерсияХранилища+1;
	
		//СписокСтрок = Новый Массив;
		//	//СписокСтрок.Добавить("Выгрузка конфигурации из хранилища успешно завершена");
		//	//успешно = НЕ ПроверитьФайлНаОтсутствиеСтрок(АппЛог2, СписокСтрок);
		//СписокСтрок.Добавить("0");
		//успешно = НЕ ПроверитьФайлНаОтсутствиеСтрок(АппЛог, СписокСтрок);
	
	ВыбФайл = Новый Файл(ИмяФайлаКонфигурации);
	успешно = ВыбФайл.Существует();
	Если успешно Тогда
		резПутьКФайлуКонфигурации = ИмяФайлаКонфигурации; //СтруктураПараметров.Вставить("ПутьКФайлуКонфигурации", ИмяФайлаКонфигурации);
	КонецЕсли;
	
	УдалитьВременныеФайлыВПопытке(АппЛог);
	
	Возврат успешно;
	
КонецФункции

Функция ПоНомеруВерсииРазобратьКонфигурациюИзХранилища1С(ПутьКБазе, версияПлатформыДляБазы, Пользователь, Пароль, ПутьКХранилищу1C, 
		ПользовательХранилища, ПарольХранилища, ПутьКФайлуХранилища1С, НомерВерсииХранилища, КаталогВыгрузкиВсехМодулей83, КаталогВыгрузки, 
		резПутьКФайлуКонфигурации) Экспорт
		
	резПутьКФайлуКонфигурации = "";
	Если НЕ ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С(ПутьКБазе, версияПлатформыДляБазы, Пользователь, Пароль, ПутьКХранилищу1C, 
		ПользовательХранилища, ПарольХранилища, ПутьКФайлуХранилища1С, НомерВерсииХранилища, резПутьКФайлуКонфигурации) Тогда
			Возврат Ложь;
	КонецЕсли;
	//Параметры.Вставить("ПутьКФайлуКонфигурации", резПутьКФайлуКонфигурации);
	
	Если НЕ РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(КаталогВыгрузкиВсехМодулей83, КаталогВыгрузки) Тогда
		Возврат Ложь;
	КонецЕсли; 
	//Параметры.Вставить("ПутьКGit", Параметры.КаталогВыгрузки);
	
	Возврат Истина;
КонецФункции
 
Функция ПроверитьСуществованиеФайлаКаталога(парамПуть, допСообщениеОшибки = "")
	Если Не ЗначениеЗаполнено(парамПуть) Тогда
		ВывестиОшибку("Не указан путь <"+допСообщениеОшибки+">");
		Возврат Ложь;
	КонецЕсли;
	
	лфайл = Новый Файл(парамПуть);
	Если Не лфайл.Существует() Тогда
		ВывестиОшибку("Не существует файл конфигурации <"+допСообщениеОшибки+">");
		Возврат Ложь;	
	КонецЕсли;
	
	Возврат Истина;
КонецФункции
 
Функция СоздатьПустуюБазу(ПутьКФайлуКонфигурации = "", резИмяКаталогаБазы = "") //Экспорт //СтруктураПараметров
	Перем ИмяФайлаВыгрузкиКаталог, строкаПутьКБазе;
	Перем СоздаемБазуПоФайлуКонфигурации, СтрокаПроверкиОшибки;

	резИмяКаталогаБазы = "";
	
	ВывестиОтладочноеСообщение("Начало создать базу "+ТекущаяДата());
	Если НЕ ПроверитьСуществованиеФайлаКаталога(ПутьКПлатформе1с83, "путь к платформе 1С 8.3") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	БылаОшибка = Ложь;
	
	ПутьКВременномуКаталогуВыгрузки = ПолучитьВременноеИмяКаталога();
	ИмяКаталогаБазы = ПолучитьПутьКНовойБазе1С(ПутьКВременномуКаталогуВыгрузки);
	ЗарегистрироватьВременныйФайл(ИмяКаталогаБазы);
	
	ВывестиОтладочноеСообщение("Каталог временной базы: " + ИмяКаталогаБазы);
	
	Если Не ПроверитьСуществованиеФайлаКаталога(ИмяКаталогаБазы, "путь к новой базе <"+ИмяКаталогаБазы+">") Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	АппЛог = ПолучитьВременноеИмяФайлаЛога();
	
	//выполняем
	Команда = """"+ПутьКПлатформе1с83+""""
			+ " CREATEINFOBASE  File=""" + ИмяКаталогаБазы+""""
			+ " /Lru"
			+ " /Out """+АппЛог+"""";
			
	СоздаемБазуПоФайлуКонфигурации = Не ПустаяСтрока(ПутьКФайлуКонфигурации); //Истина;
	
	Если СоздаемБазуПоФайлуКонфигурации Тогда
		СоздатьКаталог(ИмяКаталогаБазы);
		
		Команда = """"+ПутьКПлатформе1с83+""""
			+ " CREATEINFOBASE  File=""" + ИмяКаталогаБазы+""""
			+ " /Lru"
			+ " /Out """+АппЛог+"""";
			
	КонецЕсли;
			
	ВывестиОтладочноеСообщение(Команда);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда);
	
	СтрокаПроверкиОшибки = "успешно завершено";
	
	Если СоздаемБазуПоФайлуКонфигурации Тогда		
		
		СписокСтрок = Новый Массив;
		СписокСтрок.Добавить(СтрокаПроверкиОшибки);	
		
		БылаОшибка = ПроверитьФайлНаОтсутствиеСтрок(АппЛог, СписокСтрок);
		
		Если БылаОшибка Тогда
			Возврат Ложь; //НЕ БылаОшибка;
		КонецЕсли;
		
		
		Команда = """"+ПутьКПлатформе1с83+"""" 
				+ " DESIGNER "+ПолучитьПодстрокуКомандыЗапуска1С_БазаДанных(ИмяКаталогаБазы)
				+ " /LoadCfg"""+ПутьКФайлуКонфигурации+""""
				+ " /Lru"
				+ " /Out """+АппЛог+"""";
				
		ВывестиОтладочноеСообщение(Команда);
		ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда);
		
		СтрокаПроверкиОшибки = "успешно завершена";
		
	КонецЕсли;
	
	СписокСтрок = Новый Массив;
	СписокСтрок.Добавить(СтрокаПроверкиОшибки);	
	БылаОшибка = ПроверитьФайлНаОтсутствиеСтрок(АппЛог, СписокСтрок);
	Если Не БылаОшибка Тогда
		резИмяКаталогаБазы = ИмяКаталогаБазы;
		УдалитьВременныеФайлыВПопытке(АппЛог);
	КонецЕсли;	
	
	ВывестиОтладочноеСообщение("Завершение: создать базу "+ТекущаяДата());
	Возврат НЕ БылаОшибка;

КонецФункции

Функция СохранитьКонфигурациюИзБазы(ПутьКФайлуКонфигурации, ИмяКаталогаБазы) //Экспорт
	Перем ИмяФайлаВыгрузкиКаталог, строкаПутьКБазе;
	
	ОптимизацияСоздания = Истина;
	ВывестиОтладочноеСообщение("Начало выгрузка базы "+ТекущаяДата());
	
	лфайл = Новый Файл(ПутьКФайлуКонфигурации);
	Если лфайл.Существует() Тогда
	//Если ПроверитьСуществованиеФайлаКаталога(ПутьКФайлуКонфигурации, "Не указан путь для записи файла конфигурации из базы") Тогда //СтруктураПараметров.ИмяФайлаВыгрузкиКонфигурации
		Попытка
			УдалитьФайлы(ПутьКФайлуКонфигурации);
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	БылаОшибка = Ложь;

	//ИмяКаталогаБазы = СтруктураПараметров.ИмяКаталогаБазы; //СтрЗаменить(_ПолучитьИмяВременногоФайла("сtr"), ".сtr", "");
	
	Если Не ПроверитьСуществованиеФайлаКаталога(ИмяКаталогаБазы, "путь к новой базе <"+ИмяКаталогаБазы+">") Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	АппЛог = ПолучитьВременноеИмяФайлаЛога();

	Команда = """"+ПутьКПлатформе1с83+"""" 
			+ " DESIGNER "+ПолучитьПодстрокуКомандыЗапуска1С_БазаДанных(ИмяКаталогаБазы)
			+ " /DumpCfg"""+ПутьКФайлуКонфигурации+""""
			+ " /Lru"
			+ " /Out"""+АппЛог+"""";
			
	ВывестиОтладочноеСообщение(Команда);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда);
	
	СтрокаПроверкиОшибки = "Сохранение конфигурации успешно завершено";
	
	//ФайлЛог = Новый Файл(АппЛог);
	
	СписокСтрок = Новый Массив;
	СписокСтрок.Добавить(СтрокаПроверкиОшибки);	
	БылаОшибка = ПроверитьФайлНаОтсутствиеСтрок(АппЛог, СписокСтрок);
	
	Если Не БылаОшибка Тогда
		лфайл = Новый Файл(ПутьКФайлуКонфигурации);
		Если НЕ лфайл.Существует() Тогда
			БылаОшибка = Истина;
			ВывестиСообщение("Не существует итоговый файл конфигурации");
		КонецЕсли;
		 
		УдалитьВременныеФайлыВПопытке(АппЛог);

	КонецЕсли;
	
	ВывестиОтладочноеСообщение("Завершение: выгрузка конфигурации "+ТекущаяДата());
	Возврат НЕ БылаОшибка;

КонецФункции


Функция СоздатьПустуюБазуБезШаблона(СтруктураПараметров) //Экспорт
	Перем ИмяФайлаВыгрузкиКаталог, строкаПутьКБазе;
	Перем СтрокаПроверкиОшибки; //ОптимизацияСоздания;

	//ОптимизацияСоздания = Истина;
	ВывестиОтладочноеСообщение("Начало создать базу "+ТекущаяДата());
	Если НЕ ПроверитьСуществованиеФайлаКаталога(ПутьКПлатформе1с83, "путь к платформе 1С 8.3") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	БылаОшибка = Ложь;
	
			// ОВСЯНКИН загадочный код, не поддерживаемый oscript
			//#Если НЕ Клиент И НЕ Сервер Тогда
			Если Ложь Тогда
				СтруктураПараметров = Новый Структура; //Справочники.Конфигурации.СоздатьЭлемент();
			КонецЕсли;
			//#КонецЕсли
	
	ПутьКВременномуКаталогуВыгрузки = ПолучитьВременноеИмяКаталога(); //СтрЗаменить(_ПолучитьИмяВременногоФайла("сtr"), ".сtr", "");
	ИмяКаталогаБазы = ПолучитьПутьКНовойБазе1С(ПутьКВременномуКаталогуВыгрузки);
	ЗарегистрироватьВременныйФайл(ИмяКаталогаБазы);

	Если Не ПроверитьСуществованиеФайлаКаталога(ИмяКаталогаБазы, "путь к новой базе <"+ИмяКаталогаБазы+">") Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	АппЛог = ПолучитьВременноеИмяФайлаЛога();

		
	СоздатьКаталог(ИмяКаталогаБазы);
	Команда = """"+ПутьКПлатформе1с83+""""
		+ " CREATEINFOBASE  File=""" + ИмяКаталогаБазы+""""
		+ " /Lru"
		+ " /Out """+АппЛог+"""";
	
	ВывестиОтладочноеСообщение(Команда);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда);
	
	//ФайлЛог = Новый Файл(АппЛог);
	//Для Индекс = 1  По 500 Цикл
	//	
	//	Если ФайлЛог.Существует() Тогда
	//		Если ФайлЛог.Размер()>0 Тогда
	//			Прервать;
	//		КонецЕсли;
	//	КонецЕсли;
	//	глВремя_Задержка(10);
	//	
	//КонецЦикла;
	//
	
	СтрокаПроверкиОшибки = "успешно завершено";
	
	СписокСтрок = Новый Массив;
	СписокСтрок.Добавить(СтрокаПроверкиОшибки);	
	БылаОшибка = ПроверитьФайлНаОтсутствиеСтрок(АппЛог, СписокСтрок);
	Если Не БылаОшибка Тогда
		СтруктураПараметров.Вставить("ИмяКаталогаБазы", ИмяКаталогаБазы);
		УдалитьВременныеФайлыВПопытке(АппЛог);

	КонецЕсли;
	
	ВывестиОтладочноеСообщение("Завершение: создать базу "+ТекущаяДата());
	Возврат НЕ БылаОшибка;

КонецФункции

Функция ВыгрузитьМодули(ИмяКаталогаБазы, Пользователь, Пароль, резКаталогВыгрузкиВсехМодулей83) //Экспорт
	резКаталогВыгрузкиВсехМодулей83 = "";
	
	Если НЕ ПроверитьСуществованиеФайлаКаталога(ПутьКПлатформе1с83, "путь к платформе 1С 8.3") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Не ПроверитьСуществованиеФайлаКаталога(ИмяКаталогаБазы, "новая база") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПутьКаталогаВыгрузкиДанных = СоздатьУникальноеИмяКаталога("v8e");//ПолучитьВременноеИмяКаталога(); //СтрЗаменить(_ПолучитьИмяВременногоФайла("сtr"), ".сtr", "");
	ЗарегистрироватьВременныйФайл(ПутьКаталогаВыгрузкиДанных);
	
	файлВыгрузкиКаталог = Новый Файл(ПутьКаталогаВыгрузкиДанных);
	Если НЕ файлВыгрузкиКаталог.Существует() Тогда
		СоздатьКаталог(ПутьКаталогаВыгрузкиДанных);
		
		Проверить(файлВыгрузкиКаталог.Существует(), "Не существует каталог <"+ПутьКаталогаВыгрузкиДанных+">. Выполнение остановлено!");
	КонецЕсли;
	
	
	//ВыбФайл = Новый Файл(ИмяКаталогаБазы+"\1Cv8.1CD");
	МассивФайлов = НайтиФайлы(ПутьКаталогаВыгрузкиДанных, "*.*");
	Проверить(МассивФайлов.Количество() = 0, "в каталоге <"+ПутьКаталогаВыгрузкиДанных+"> не должно быть файлов");
			

	строкаПутьКБазе = ПолучитьПодстрокуКомандыЗапуска1С_БазаДанных(ИмяКаталогаБазы); //СтруктураПараметров.ПутьКБазе);
	
	СтрокаЛогина = ПолучитьСтрокуЛогинаКомандыЗапуска1С(Пользователь, Пароль);
		//СтрокаЛогина = "";
		//Если СтруктураПараметров.Свойство("Пользователь") И ЗначениеЗаполнено(СтруктураПараметров.Пользователь) Тогда
		//	СтрокаЛогина = ПолучитьСтрокуЛогинаКомандыЗапуска1С(СтруктураПараметров.Пользователь, СтруктураПараметров.Пароль);
		//КонецЕсли;
	
		//СтрокаХранилища = " /ConfigurationRepositoryF"""+СтруктураПараметров.ПутьКХранилищу1C+"""";
		//СтрокаЛогинаХранилища = ПолучитьПодстрокуКомандыЗапуска1С_Хранилище(СтруктураПараметров.ПользовательХранилища, СтруктураПараметров.ПарольХранилища);
		//
	АппЛог = ПолучитьВременноеИмяФайлаЛога();
	
	// TODO иногда бывает баг параллельной работы: при одновременном запуске (с точностью до секунды) двух пакетных выгрузок один из запущенных процессов 1С зависает.
	// а в итоге висит и обработчик 1C2Git. Для продолжения работы нужно удалить запущенный процесс.
	// баг найден на 8.3.3.721
	// код ниже решает эту проблему
	// ОВСЯНКИН -- этот код с отложенным запуском не используется, т.е. мертвый.
	// Если ИспользоватьРежимОтложенногоЗапускаВыгрузкиМодулейИзКонфигуратора Тогда
		// МожноЗапускать = МожноЗапускатьКонфигураторВПакетномРежиме(ЗадержкаЗапускаВыгрузкиМодулейИзКонфигуратора);
	// КонецЕсли;
	
			//ПутьК1С83 = ПолучитьПутьПлатформы1С_83();
	Команда = """"+ПутьКПлатформе1с83+"""" //ПутьК1С83
		+ " DESIGNER " + строкаПутьКБазе + " "
		+ СтрокаЛогина
		+ " /Visible"
		+ " /DumpConfigToFiles""" + ПутьКаталогаВыгрузкиДанных  + """"
		+ " /Lru"
		//для 1С 8.2 строка		+ " /DumpConfigFiles""" + ПутьКаталогаВыгрузкиДанных + """ -Module -Template -AllWritable -Right -Picture"
		+ " /Out"""+АппЛог+"""";
		
	// #Если Клиент Тогда
		// Состояние("Выполняется выгрузка модулей конфигурации ...");
	// #КонецЕсли 
	
	СписокФайлов = НайтиФайлы(ПутьКаталогаВыгрузкиДанных, "*.*");
	//Если СписокФайлов.Количество() > 0 Тогда
	//	ВывестиОшибку("В папке выгрузки <"+ПутьКаталогаВыгрузкиДанных+"> существуют файлы. Выполнение остановлено!");	
	//Иначе
		ВывестиОтладочноеСообщение("ВыгрузитьМодули: команда "+ Команда);
		ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда);
	//КонецЕсли;
	
	резКаталогВыгрузкиВсехМодулей83 = ПутьКаталогаВыгрузкиДанных; //СтруктураПараметров.Вставить("КаталогВыгрузкиВсехМодулей83", ПутьКаталогаВыгрузкиДанных);
	
	МассивФайлов = НайтиФайлы(ПутьКаталогаВыгрузкиДанных,"*.*");
	Проверить(МассивФайлов.Количество() > 0, "в каталоге <"+ПутьКаталогаВыгрузкиДанных+"> должны быть файлы");
	
	УдалитьВременныеФайлыВПопытке(АппЛог);
	//МассивФайлов = НайтиФайлы(КаталогВыгрузки, "*.*");
	//Проверить(МассивФайлов.Количество() > 0, "в каталоге <"+КаталогВыгрузки+"> должны быть файлы");
	
	Возврат Истина; //естьСтрокаВФайлеТрассировки;	
	
КонецФункции

// ОВСЯНКИН - сделай сам
Функция СтрЧислоВхождений(Знач СтогСена, Знач Иголка)

	ЧислоВхождений = 0;
	ДлинаИголки = СтрДлина(Иголка);
	Поз = -1;
	Пока Поз <> 0 Цикл
		Поз = Найти(СтогСена, Иголка);
		Если Поз > 0 Тогда
			ЧислоВхождений = ЧислоВхождений + 1;
			СтогСена = Сред(СтогСена, Поз + ДлинаИголки);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ЧислоВхождений;
	
КонецФункции

Функция НовыйСписокПереименований()

	Возврат Новый Массив();
	
	// если использовать ТаблицуЗначений, то:
	// ТаблицаПереименований = Новый ТаблицаЗначений;
	// Переименования = Новый ТаблицаЗначений;
	// Переименования.Колонки.Добавить("Источник", Новый ОписаниеТипов("Строка", ,Новый КвалификаторыСтроки(500, ДопустимаяДлина.Переменная)));
	// Переименования.Колонки.Добавить("Приемник", Новый ОписаниеТипов("Строка", ,Новый КвалификаторыСтроки(500, ДопустимаяДлина.Переменная)));

КонецФункции

Функция ДобавитьПереименование(Знач Переименования, Знач Источник, Знач Приемник)

	СтрокаПереименования = Новый Структура;
	СтрокаПереименования.Вставить("Источник", Источник);
	СтрокаПереименования.Вставить("Приемник", Приемник);
	
	Переименования.Добавить(СтрокаПереименования);
	
	Возврат СтрокаПереименования;

КонецФункции

Функция РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(КаталогВыгрузкиВсехМодулей83, КаталогВыгрузки) Экспорт
	Перем КаталогИерархическойСтруктурыМодулей;
	Перем КэшПереименований;
	Перем СоотвествиеИменФайловДляПропуска;
	
	КэшПереименований = Новый Соответствие;
	лПутьКаталогаВыгрузкиВсехМодулей83 = КаталогВыгрузкиВсехМодулей83; //ПутьКаталогаВыгрузки;
	Если Не ПроверитьСуществованиеФайлаКаталога(лПутьКаталогаВыгрузкиВсехМодулей83, "каталог выгрузки всех модулей 8.3 - РазложитьМодули1СПоПапкамСогласноИерархииМетаданных") Тогда
		Возврат Ложь;
	КонецЕсли;
		
	КаталогИерархическойСтруктурыМодулей = КаталогВыгрузки;
	Если ПустаяСтрока(КаталогИерархическойСтруктурыМодулей) Тогда
		ВывестиОшибку("не задан каталог выгрузки модулей по иерархии - РазложитьМодули1СПоПапкамСогласноИерархииМетаданных");
		Возврат Ложь;
	КонецЕсли;
		//ВызватьИсключение "КаталогИерархическойСтруктурыМодулей (разложенные модули) не должен равняться лПутьКаталогаВыгрузки (общий набор всех файлов выгруженных из 8.3)";
	
	лФайлВыгрузкиКаталог = Новый Файл(КаталогИерархическойСтруктурыМодулей);
	Если НЕ лФайлВыгрузкиКаталог.Существует() Тогда
		СоздатьКаталог(КаталогИерархическойСтруктурыМодулей);
		ЗарегистрироватьВременныйФайл(КаталогИерархическойСтруктурыМодулей);
		
		Проверить(лФайлВыгрузкиКаталог.Существует(), "Не существует каталог иерархии модулей <"+КаталогИерархическойСтруктурыМодулей+">. Выполнение остановлено!");
	КонецЕсли;
	
	
	СтрокаКомманды = "taskkill /im TGitCache.exe  /T /F";
	ВывестиОтладочноеСообщение("РазложитьМодули1СПоПапкамСогласноИерархииМетаданных: команда "+ СтрокаКомманды);

	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(СтрокаКомманды); //,,Истина,,Истина);
	
	СоответствиеИменФайловДляПропуска = Новый Соответствие;
	СоответствиеИменФайловДляПропуска.Вставить(".git", Истина);
	СоответствиеИменФайловДляПропуска.Вставить("AUTHORS", Истина); //Соответствие авторов и транслитерации. 
	СоответствиеИменФайловДляПропуска.Вставить("VERSION", Истина); //Номер версии, может использоватся для синхронизации с хранилищем. 
	
	
	//Удалим все каталоги с файлами в папке для разбора, кроме папки, начинающейся с с точки.
	ЕстьОшибкаУдаления = Ложь;
	МассивФайлов = НайтиФайлы(КаталогИерархическойСтруктурыМодулей, "*.*");
	Если МассивФайлов.Количество()>0 Тогда
		Для каждого ЭлементМассива Из МассивФайлов Цикл
			Если СоответствиеИменФайловДляПропуска.Получить(ЭлементМассива.Имя) = Истина Тогда
				Продолжить;
			КонецЕсли;
			Попытка
				УдалитьФайлы(ЭлементМассива.ПолноеИмя);
			Исключение
				ЕстьОшибкаУдаления = Истина;
			КонецПопытки;
		КонецЦикла;
	КонецЕсли;
	
	Если ЕстьОшибкаУдаления Тогда
		
		ЕстьОшибкаУдаления = Ложь;
		МассивФайлов = НайтиФайлы(КаталогИерархическойСтруктурыМодулей, "*.*");
		Если МассивФайлов.Количество()>0 Тогда
			Для каждого ЭлементМассива Из МассивФайлов Цикл
				Если СоответствиеИменФайловДляПропуска.Получить(ЭлементМассива.Имя) = Истина Тогда
					Продолжить;
				КонецЕсли;
				//Попытка
					УдалитьФайлы(ЭлементМассива.ПолноеИмя);
				//Исключение
				//	ЕстьОшибкаУдаления = Истина;
				//КонецПопытки;
			КонецЦикла;
		КонецЕсли;
		
		
	КонецЕсли;
		
	Переименования = НовыйСписокПереименований();
	
	СписокФайлов = НайтиФайлы(лПутьКаталогаВыгрузкиВсехМодулей83, "*.*"); //СтруктураПараметров.КаталогВыгрузки
	Для каждого Файл Из СписокФайлов Цикл
		Если Файл.ЭтоКаталог() Тогда
			
			Если Прав(Файл.Имя, 5) = "files" Тогда // файлы справки. 
				МассивФайлов = НайтиФайлы(Файл.ПолноеИмя, "*.*");
				ИмяНовогоФайла = Лев(Файл.Имя, СтрДлина(Файл.Имя)-6);
				ИмяНовогоФайла = СтрЗаменить(ИмяНовогоФайла, ".", "\")+".del";
				НовыйФайл = Новый Файл(КаталогИерархическойСтруктурыМодулей+"\"+ИмяНовогоФайла);
				НовыйКаталог = Новый Файл(НовыйФайл.Путь);
				Если НЕ НовыйКаталог.Существует() Тогда
					СоздатьКаталог(НовыйКаталог.ПолноеИмя);
				КонецЕсли;
				НовыйФайл = Новый Файл(НовыйКаталог.ПолноеИмя+"\"+Файл.Имя);
				Если Не НовыйФайл.Существует() Тогда
					СоздатьКаталог(НовыйФайл.ПолноеИмя);
				КонецЕсли;
				Для каждого ЭлементЦикла Из МассивФайлов Цикл
					ДобавитьПереименование(Переименования, 
						Файл.Имя+"\"+ЭлементЦикла.Имя, 
						СтрЗаменить(НовыйФайл.ПолноеИмя+"\"+ЭлементЦикла.Имя, КаталогИерархическойСтруктурыМодулей+"\", ""));
				КонецЦикла;
			КонецЕсли;
			Продолжить;	
		КонецЕсли;
		ИмяФайла = Файл.ИмяБезРасширения;
		//Форма.Модуль --> МодульФормы
		Если Прав(ИмяФайла, 12) = "Форма.Модуль" Тогда
			ИмяФайла = Лев(ИмяФайла, СтрДлина(ИмяФайла)-12)+"МодульФормы";
		КонецЕсли;
		
		Если Прав(ИмяФайла, 6) = ".Макет" Тогда
			ИмяФайла = Лев(ИмяФайла, СтрДлина(ИмяФайла)-6);
		КонецЕсли;
		
		Если Прав(ИмяФайла, 17) = ".Картинка.Picture" Тогда
			ИмяФайла = Лев(ИмяФайла, СтрДлина(ИмяФайла)-17);
		КонецЕсли;
		
		Если Прав(ИмяФайла, 5) = ".Form" Тогда
			
		КонецЕсли;
		
		// Для 8.3 если файл содержит всего одну точку в имени, тогда создадим папки и туда его и кинем. 
		// 
		
		Если СтрЧислоВхождений(ИмяФайла, ".") = 1 Тогда
			//Увеличим наименование на Наименование объекта конфигурации описываемого. 
			//
			НаименованиеОбъектаМетаданных = Сред(ИмяФайла, Найти(ИмяФайла, "."));
			ИмяФайла = СтрЗаменить(ИмяФайла, НаименованиеОбъектаМетаданных,НаименованиеОбъектаМетаданных+НаименованиеОбъектаМетаданных);
		КонецЕсли;
		
		//{Определим длину Наименования папки, по умолчанию не больше 60 символов.  
		Если СтрДлина(ИмяФайла)>144 Тогда
		
			МассивИмен = РазложитьСтрокуВМассивПодстрок(ИмяФайла, ".");
			//Для каждого  Из  Цикл
			//КонецЦикла;
			//СтрокаПапки = Сред(ИмяФайла, Найти(ИмяФайла, "."));
			//СтрокаПапки = Сред(СтрокаПапки, 0, Найти(СтрокаПапки, "."));
			//Если СтрДлина(СтрокаПапки) > 59 Тогда
				
				ИмяФайла = "";
				Счетчик = 0;
				КоличествоВсего = МассивИмен.Количество();
				Для Счетчик = 0 По КоличествоВсего-1 Цикл
					ЭлементМассива = МассивИмен.Получить(Счетчик);
					НовоеИмя = ЭлементМассива;
					ДлинаИменни = СтрДлина(ЭлементМассива);
					//Если ДлинаИменни > 58 И (Счетчик <> (КоличествоВсего-1)) Тогда
					
					Если ДлинаИменни > 58 Тогда
						ВывестиОтладочноеСообщение("Слишком длинное имя:"+ЭлементМассива +" длина:"+ДлинаИменни);
						
						Если КэшПереименований.Получить(ЭлементМассива) <> Неопределено Тогда
							НовоеИмя = КэшПереименований.Получить(ЭлементМассива);
						Иначе
							Разрядность = СтрДлина(Строка(ДлинаИменни));
							НовоеИмя = Лев(ЭлементМассива, 58-Разрядность-1)+"~"+ДлинаИменни;
							НовыйПутьПроверки = Новый Файл(КаталогИерархическойСтруктурыМодулей+"\"+ИмяФайла+НовоеИмя);
							Если НовыйПутьПроверки.Существует() Тогда
								СчетчикНовогоИмени = 0;
								МассивФайловСущуствующих = НайтиФайлы(КаталогИерархическойСтруктурыМодулей+"\"+ИмяФайла, Лев(ЭлементМассива, 58-Разрядность-3)+"*");
								СчетчикНовогоИмени = МассивФайловСущуствующих.Количество()+1;
								НовоеИмя = Лев(ЭлементМассива, 58-Разрядность-3)+"~"+ДлинаИменни+ФорматДвузначноеЧисло(Строка(СчетчикНовогоИмени));
							КонецЕсли;
							
							КэшПереименований.Вставить(ЭлементМассива, НовоеИмя);
						КонецЕсли;
						
						ВывестиОтладочноеСообщение("Старое имя:"+ЭлементМассива +" новое имя:"+НовоеИмя);
					КонецЕсли;
					ИмяФайла=ИмяФайла+НовоеИмя+"\";
				КонецЦикла;
				ИмяФайла = ?(Прав(ИмяФайла,1)="\", Лев(ИмяФайла, СтрДлина(ИмяФайла)-1), ИмяФайла);
			//КонецЕсли;
		КонецЕсли;
		//}
		
		ИмяНовогоФайла = СтрЗаменить(ИмяФайла, ".", "\")+Файл.Расширение;
		НовыйФайл = Новый Файл(КаталогИерархическойСтруктурыМодулей+"\"+ИмяНовогоФайла);
		НовыйКаталог = Новый Файл(НовыйФайл.Путь);
		Если НЕ НовыйКаталог.Существует() Тогда
			СоздатьКаталог(НовыйКаталог.ПолноеИмя);
		КонецЕсли;
		
		ДобавитьПереименование(Переименования,Файл.Имя,ИмяНовогоФайла);
		
		КопироватьФайл(Файл.ПолноеИмя, НовыйФайл.ПолноеИмя);
		
		Если Прав(Файл.ПолноеИмя, 5) = ".Form" Тогда
			
			//Если ФайлПрограммыРаспаковки=Неопределено или НЕ ФайлПрограммыРаспаковки.Существует() тогда
			//	Инициализация();
			//КонецЕсли;
			
			КаталогФормы = НовыйКаталог.ПолноеИмя+"\"+НовыйФайл.ИмяБезРасширения;
			СоздатьКаталог(КаталогФормы);
			
			Если Не Распаковка(НовыйФайл.ПолноеИмя, КаталогФормы) Тогда
				Возврат Ложь;
			КонецЕсли; 
			
		КонецЕсли;
		//"000009d5 000009d5 7fffffff"
		
	КонецЦикла;
	
	ТекстовыйДокумент = Новый ЗаписьТекста(КаталогИерархическойСтруктурыМодулей+"\renames.txt");
	Для Каждого ЭлементСтроки Из Переименования Цикл
		ТекстовыйДокумент.ЗаписатьСтроку(ЭлементСтроки.Источник+"-->"+ЭлементСтроки.Приемник);
	КонецЦикла;
	ТекстовыйДокумент.Закрыть();
	//Переименования.Сортировать("Источник");
	// ТекстовыйДокумент = Новый ТекстовыйДокумент;
	// Для каждого ЭлементСтроки Из Переименования Цикл
		// ТекстовыйДокумент.ДобавитьСтроку(ЭлементСтроки.Источник+"-->"+ЭлементСтроки.Приемник);
	// КонецЦикла;
	// ТекстовыйДокумент.Записать(КаталогИерархическойСтруктурыМодулей+"\renames.txt");
	//----
	
	Возврат  Истина;
	
КонецФункции

Функция РазложитьКонфигурацию1СПоПапкамСогласноИерархииМетаданных(Пользователь, Пароль, ПутьКФайлуКонфигурации, КаталогВыгрузки, резИмяКаталогаБазы )
	
	Если НЕ СоздатьПустуюБазу(ПутьКФайлуКонфигурации, резИмяКаталогаБазы) Тогда
		ВывестиОшибку("Не удалось выполнить создание пустой базы по cf");
		Возврат Ложь;
	КонецЕсли; 
	
	КаталогВыгрузкиВсехМодулей83 = "";
	Если НЕ ВыгрузитьМодули(резИмяКаталогаБазы, Пользователь, Пароль, КаталогВыгрузкиВсехМодулей83) Тогда
		ВывестиОшибку("Не удалось выгрузить модули");
		Возврат Ложь;
	КонецЕсли; 
	
	Если НЕ РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(КаталогВыгрузкиВсехМодулей83, КаталогВыгрузки) Тогда
		ВывестиОшибку("Не удалось выполнить копирование файлов");
		Возврат Ложь;
	КонецЕсли; 
	
	МассивФайлов = НайтиФайлы(резИмяКаталогаБазы, "*.*");
	УдалитьВременныеФайлыВПопытке(резИмяКаталогаБазы);
	УдалитьВременныеФайлыВПопытке(КаталогВыгрузкиВсехМодулей83);

		
	Возврат Истина;
КонецФункции

Функция СобратьМодули1СИзИерарархииМетаданныхВЛинейнуюСтруктуру(СтруктураПараметров) Экспорт
	Перем КаталогСтруктуры;
	

	ПутьКВременномуКаталогуПереименований = ПолучитьВременноеИмяКаталога(); //СтрЗаменить(_ПолучитьИмяВременногоФайла("сtr"), ".сtr", "");;
	//СоздатьКаталог(ПутьКВременномуКаталогуПереименований);
		
	ИмяФайлаВыгрузкиКаталог = СтруктураПараметров.КаталогЗагрузки;
	файлВыгрузкиКаталог = Новый Файл(ИмяФайлаВыгрузкиКаталог);
	Проверить(файлВыгрузкиКаталог.Существует(), "файл с исходными данными не существует");
	Проверить(файлВыгрузкиКаталог.ЭтоКаталог(), "путь с исходными данными не каталог");
	
	файлПереименований = Новый Файл(файлВыгрузкиКаталог.ПолноеИмя + "\renames.txt");
	Проверить(файлПереименований.Существует(), "файл со списком переименований существует. ");
	
	СтрокаКомманды = "taskkill /im TGitCache.exe ";
	ВывестиОтладочноеСообщение("СкопироватьСтруктуруИСделатьCommit: команда "+ СтрокаКомманды);

	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(СтрокаКомманды); //,,Истина,,Истина);
	
	ЕстьОшибка = Ложь;
	ЧтениеТекста = Новый ЧтениеТекста(файлПереименований.ПолноеИмя);
	
	Стр = ЧтениеТекста.ПрочитатьСтроку();
	Пока Стр <> Неопределено Цикл // строки читаются до символа перевода строки
		ИндексПоиска = Найти(Стр, "-->");
		Если СтрДлина(Стр)>0 И ИндексПоиска > 0 Тогда 
			
			ПутьФайлНовый = Сред(Стр, 0, ИндексПоиска-1);
			ПолныйПутьНовыйФайл = ПутьКВременномуКаталогуПереименований + "\"+ПутьФайлНовый;
			ПутьФайлСтарый = Сред(Стр, ИндексПоиска+3);
			ПолныйПутьСтарыйФайл = файлВыгрузкиКаталог.ПолноеИмя+"\"+ПутьФайлСтарый;
			Если Прав(ПолныйПутьНовыйФайл, 5) = ".Form" Тогда
				
				ФайлСтарый = Новый Файл(ПутьФайлСтарый);
				
				//Если ФайлПрограммыРаспаковки=Неопределено или НЕ ФайлПрограммыРаспаковки.Существует() тогда
				//	Инициализация();
				//КонецЕсли;
				
				КаталогФормы = ФайлСтарый.Путь+"\"+ФайлСтарый.ИмяБезРасширения;
				
				Если Не Упаковка(ФайлСтарый.ПолноеИмя, КаталогФормы) Тогда
					Возврат Ложь;
				КонецЕсли; 
			КонецЕсли;
			
			КопироватьФайл(ПолныйПутьСтарыйФайл, ПолныйПутьНовыйФайл);
			
		ИначеЕсли СтрДлина(Стр)>0 Тогда
			ЕстьОшибка = Истина;
			Прервать;
			
	    КонецЕсли;
		
		Стр = ЧтениеТекста.ПрочитатьСтроку();
	КонецЦикла;
	
	Если ЕстьОшибка Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СтруктураПараметров.Вставить("ПутьКВременномуКаталогуПереименований", ПутьКВременномуКаталогуПереименований);

	Возврат  Истина;
	
КонецФункции


Функция ЗагрузитьМодули(СтруктураПараметров) Экспорт
	
	файлВыгрузкиКаталог = Новый Файл(СтруктураПараметров.ПутьКВременномуКаталогуПереименований);
	Проверить(файлВыгрузкиКаталог.Существует(), "Не существует каталог <"+СтруктураПараметров.ПутьКВременномуКаталогуПереименований+">. Выполнение остановлено!");
	
	МассивФайлов = НайтиФайлы(СтруктураПараметров.ПутьКВременномуКаталогуПереименований, "*.*");
	Проверить(МассивФайлов.Количество() > 0, "в каталоге <"+СтруктураПараметров.ПутьКВременномуКаталогуПереименований+"> не должно быть файлов");
			

	строкаПутьКБазе = ПолучитьПодстрокуКомандыЗапуска1С_БазаДанных(СтруктураПараметров.ИмяКаталогаБазы); //СтруктураПараметров.ПутьКБазе);
	
	строкаЛогина = ПолучитьПодстрокуКомандыЗапуска1С_ЛогинПароль(); //СтруктураПараметров.Пользователь, СтруктураПараметров.Пароль);
	
	АппЛог = ПолучитьВременноеИмяФайлаЛога();
	
	Команда = """"+ПутьКПлатформе1с83+""""
		+ " DESIGNER " + строкаПутьКБазе
		+ СтрокаЛогина
		+ " /Visible"
		+ " /LoadConfigFromFiles""" + СтруктураПараметров.ПутьКВременномуКаталогуПереименований + """"
		+ " /Lru"
		+ " /Out"""+АппЛог+"""";
		
		
	ВывестиОтладочноеСообщение("ЗагрузитьМодули: команда "+ Команда);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Команда);
	
	СписокСтрок = Новый Массив;
	//Пишет только при ошибке, поэтому считаем если нашли, то ошибка есть. 
	СписокСтрок.Добавить("Ошибка разбора");
	БылаОшибка = ПроверитьФайлНаОтсутствиеСтрок(АппЛог, СписокСтрок);
	
	Если БылаОшибка Тогда
		Возврат Ложь;
	Иначе
		УдалитьВременныеФайлыВПопытке(АппЛог);

	КонецЕсли;
	
	Возврат Истина; //естьСтрокаВФайлеТрассировки;	
	
КонецФункции

Функция СобратьКонфигурацию1СПоПапкамСогласноИерархииМетаданных(СтруктураПараметров)
	
	Если НЕ СоздатьПустуюБазуБезШаблона(СтруктураПараметров) Тогда
		ВывестиОшибку("Не удалось выполнить создание пустой базы по cf");
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ СобратьМодули1СИзИерарархииМетаданныхВЛинейнуюСтруктуру(СтруктураПараметров) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗагрузитьМодули(СтруктураПараметров) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ СохранитьКонфигурациюИзБазы(СтруктураПараметров.ПутьКФайлуКонфигурации, СтруктураПараметров.ИмяКаталогаБазы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	МассивФайлов = НайтиФайлы(СтруктураПараметров.ИмяКаталогаБазы, "*.*");
	Попытка
		УдалитьФайлы(СтруктураПараметров.ИмяКаталогаБазы);
	Исключение
		ВывестиОшибку(ОписаниеОшибки());
	КонецПопытки;
	
	МассивФайлов = НайтиФайлы(СтруктураПараметров.ПутьКВременномуКаталогуПереименований, "*.*");
	Попытка
		УдалитьФайлы(СтруктураПараметров.ПутьКВременномуКаталогуПереименований);
	Исключение
		ВывестиОшибку(ОписаниеОшибки());
	КонецПопытки;
	
	Возврат Истина;
КонецФункции

Функция СинхронизироватьХранилищеКонфигурацийСГит(СтруктураПараметров) Экспорт
	Перем МаксимальнаяВерсияДляРазбора;
	
	МаксимальнаяВерсияДляРазбора = 0;
	
	ТаблицаИсторииХранилища = Неопределено;
	ТаблицаАвторовХранилища = Неопределено;
	ТаблицаПользователейГит = Неопределено;
	ТекущаяВерсия = "";
	
	Если НЕ ПолучитьТаблицуВерсийИзФайлаХранилищаГит(СтруктураПараметров.КаталогВыгрузки, СтруктураПараметров.ПутьКФайлуХранилища1С, ТаблицаИсторииХранилища, ТаблицаАвторовХранилища, ТаблицаПользователейГит, ТекущаяВерсия) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	//ТекущаяВерсия = СтруктураПараметров.ТекущаяВерсия;
	//ТаблицаИсторииХранилища = СтруктураПараметров.ТаблицаИсторииХранилища;
	
	ЧислоВерсийПлюс = 0;
	Если СтруктураПараметров.Свойство("МаксимальнаяВерсия") Тогда
		Попытка
			ЧислоВерсийПлюс = Число(СтруктураПараметров.МаксимальнаяВерсия);
		Исключение
			ЧислоВерсийПлюс = 0;
		КонецПопытки;
	КонецЕсли;
	Если ЧислоВерсийПлюс>0 Тогда
		МаксимальнаяВерсияДляРазбора = ТекущаяВерсия + ЧислоВерсийПлюс;
	Иначе
		МаксимальнаяВерсияДляРазбора = ТаблицаИсторииХранилища[ТаблицаИсторииХранилища.Количество()-1].НомерВерсии;
	КонецЕсли;
	СледующаяВерсия = ТекущаяВерсия + 1;	
	
	успешно = Истина;
	
	Пока успешно Цикл
		
		СтрокаВерсии = ТаблицаИсторииХранилища.Найти(СледующаяВерсия, "НомерВерсии");
		Если СтрокаВерсии <> Неопределено Тогда
			
			Проверить(НЕ ПустаяСтрока(СтрокаВерсии.ПредставлениеАвтора), "Нашли следующую версию, а автор не прописан "+СледующаяВерсия + " автор "+СтрокаВерсии.Автор);
			
			успешно = ЗаписатьФайлВерсийГит(СтруктураПараметров.КаталогВыгрузки+"\VERSION",СледующаяВерсия);
				Проверить(успешно, "Не удалось записать файл версии для "+ СледующаяВерсия);
			
			резПутьКФайлуКонфигурации = "";
			успешно = РазложитьМодули1СпоНомеруВерсииХранилища1С("", "", "", "",СтруктураПараметров.ПутьКФайлуХранилища1С, 
				"", "", СтруктураПараметров.ПутьКФайлуХранилища1С, СледующаяВерсия, СтруктураПараметров.КаталогВыгрузки, "", 
				резПутьКФайлуКонфигурации);
			
			//успешно = РазложитьМодули1СпоНомеруВерсииХранилища1С(СтруктураПараметровДляКоммит);
			Проверить(успешно, "синхронизация с Git, версия <"+СледующаяВерсия+"> - не удалось выполнить РазложитьМодули1СпоНомеруВерсииХранилища1С");	
			//	
			успешно = ВыполнитьКоммитГит(СтруктураПараметров.КаталогВыгрузки, СтрокаВерсии.Комментарий, СтрокаВерсии.ПредставлениеАвтора, СтрокаВерсии.Дата);
			Проверить(успешно, "синхронизация с Git, версия <"+СледующаяВерсия+"> - не удалось выполнить ВыполнитьКоммитГит");
			
			ТекущаяВерсия = СледующаяВерсия;			
		КонецЕсли;
		
		СледующаяВерсия = СледующаяВерсия + 1;
		
		Если СледующаяВерсия > МаксимальнаяВерсияДляРазбора Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ФорматДвузначноеЧисло(ЗначениеЧисло)
	С = Строка(ЗначениеЧисло);
	Если СтрДлина(С) < 2 Тогда
		С = "0" + С;
	КонецЕсли;
	
	Возврат С;
КонецФункции

Функция ДатаPOSIX(Знач Дата)
	
	Возврат "" + Год(Дата) + "-" + ФорматДвузначноеЧисло(Месяц(Дата)) + "-" + ФорматДвузначноеЧисло(День(Дата)) + " "
			+ ФорматДвузначноеЧисло(Час(Дата)) + ":" + ФорматДвузначноеЧисло(Минута(Дата)) + ":" + ФорматДвузначноеЧисло(Секунда(Дата));
	
	//Формат(Дата, "Л=en_US_POSIX; ДФ='yyyy-MM-dd hh:mm:ss'; ДЛФ=DDT")
	
КонецФункции

//TODO сделать тест Чисто git комманды. 
Функция ВыполнитьКоммитГит(КаталогРепозиторияГит, Комментарий, Автор, Дата=Неопределено) Экспорт 
 	
	ФайлРепозиторияГит = Новый Файл(КаталогРепозиторияГит+"\.git");
	Если Не ФайлРепозиторияГит.Существует() Тогда
		ВывестиОшибку("Не найден репозитарий git. Нет подкаталога .git в каталоге <"+КаталогРепозиторияГит+"> ");
		Возврат Ложь;
	КонецЕсли;
	
	Если Дата = Неопределено Тогда
	//Если Дата = Неопределено ИЛИ ТипЗнч(Дата) <> Тип("Дата") Тогда
		Дата = ТекущаяДата();
	КонецЕсли;

	ИмяФайлаКомментария = _ПолучитьИмяВременногоФайла("txt");
	файлКомментария = Новый ЗаписьТекста(ИмяФайлаКомментария,"utf-8");
	файлКомментария.Записать(?(ПустаяСтрока(Комментарий), ".", Комментарий));
	файлКомментария.Закрыть();
	
	ИмяФайлаВыполнения = _ПолучитьИмяВременногоФайла("bat");
	ФайлДляВыполнения = Новый ЗаписьТекста(ИмяФайлаВыполнения, "cp866");
	
	ФайлДляВыполнения.ЗаписатьСтроку("cd /d """ + КаталогРепозиторияГит+"""");
	ФайлДляВыполнения.ЗаписатьСтроку("set GIT_AUTHOR_DATE="""+ДатаPOSIX(Дата)+"""");
	ФайлДляВыполнения.ЗаписатьСтроку("git add .");
	
	ИмяФайлаЛогаКоммита = _ПолучитьИмяВременногоФайла("log");
	
	авторДляГит = Автор;
	Если Найти(Автор, "<") <= Найти(Автор, ">") Тогда // TODO можно также юзать регулярное выражение
		авторДляГит = Автор+" <"+Автор+"@localhost>"; // e-mail может быть удобен для поиска в связанных системах //авторДляГит = Автор+" <"+Автор+">";
				//Если Найти(Автор, "@") = 0 или Найти(Автор, "<") = 0 или Найти(Автор, ">") = 0 Тогда // TODO можно также юзать регулярное выражение
	КонецЕсли; 
	СтрокаДляЗаписи = "git commit -a --file="""+ИмяФайлаКомментария+""" --author="""+Автор+""" >"+ИмяФайлаЛогаКоммита;
	
	ФайлДляВыполнения.ЗаписатьСтроку(СтрокаДляЗаписи);
			//ФайлДляВыполнения.ДобавитьСтроку("git tag -a "+СтруктураПараметров.Тэг +" -m "+СтруктураПараметров.Тэг);
			
	ФайлДляВыполнения.ЗаписатьСтроку("exit /b %ERRORLEVEL%");
	ФайлДляВыполнения.Закрыть();
	
	ВывестиОтладочноеСообщение("ВыполнитьКоммитГит: команда "+ ИмяФайлаВыполнения);
	текстФайла = "";
	Если ПолучитьТекстФайла(ИмяФайлаВыполнения, текстФайла) Тогда
		ВывестиОтладочноеСообщение("ВыполнитьКоммитГит: текст файла запуска "+Символы.ВК+текстФайла);
	Иначе
		ВывестиОшибку("ВыполнитьКоммитГит: не удалось вывести текст пакетного файла");
	КонецЕсли;
	
	рез = ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(ИмяФайлаВыполнения); //,,Истина,,Истина);
	
	ВывестиОтладочноеСообщение("ВыполнитьКоммитГит: Вызов git commit вернул код <" + рез + "> ");
	
	Если рез <> 0 Тогда
		текстФайла = "";
		успешно = ПолучитьТекстФайла(ИмяФайлаЛогаКоммита, текстФайла);
		Если успешно Тогда
			ВывестиОшибку("ВыполнитьКоммитГит: Лог команды git commit"+Символы.ПС+текстФайла);
		Иначе
			ВывестиОшибку("ВыполнитьКоммитГит: Не удалось получить лог команды git commit");
		КонецЕсли; 

	КонецЕсли;

	УдалитьВременныеФайлыВПопытке(ИмяФайлаВыполнения);
	УдалитьВременныеФайлыВПопытке(ИмяФайлаКомментария);
	
	Возврат рез = 0;
КонецФункции

Функция ПолучитьТекстФайла(ИмяФайла, резТекстФайла = "")
	
	// проверим есть ли файл
	Файл = Новый Файл(ИмяФайла);
	Если НЕ Файл.Существует() Тогда
		Возврат Ложь;
	КонецЕсли;

	ФайлОтчета = Новый ЧтениеТекста(ИмяФайла);
	МассивСтрок = Новый Массив;
	
	Попытка
		Стр = "";
		Пока Стр <> Неопределено Цикл
			Стр = ФайлОтчета.ПрочитатьСтроку();
			МассивСтрок.Добавить(Стр);
		КонецЦикла;
		ФайлОтчета.Закрыть();
	Исключение
		ВывестиОшибку("При выводе файла возникла ошибка: "+ОписаниеОшибки());
		Возврат Ложь;
	КонецПопытки;
	Если МассивСтрок.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	// вывести если строки не нашлись
	текстФайла = "+---/ "+ИмяФайла+" /-------------------------------";
	Для Инд = 0 По МассивСтрок.Количество()-1 Цикл
		текстФайла = текстФайла + Символы.ПС + "|"+МассивСтрок[Инд];
	КонецЦикла;
	текстФайла = текстФайла + Символы.ПС + "+-------------";
	резТекстФайла = текстФайла;

	Возврат Истина;
КонецФункции

//Функция ПроверитьФайлНаОтсутствиеСтрок(ИмяФайла,СтрокаСравнение="",СтрокаПроверки=0) Экспорт
// возвращает истина если выведен_файл/не_найдена_фраза
Функция ПроверитьФайлНаОтсутствиеСтрок(ИмяФайла,СписокСтрокПоиска) //Экспорт
	
	// проверим есть ли файл
	Файл = Новый Файл(ИмяФайла);
	Если Файл.Существует() Тогда
		Попытка
			ФайлОтчета = Новый ЧтениеТекста(ИмяФайла);
		Исключение
			ФайлОтчета.Закрыть();
			ВывестиОшибку("При выводе файла возникла ошибка: "+ОписаниеОшибки());
			Возврат Ложь;
		КонецПопытки;
		
		Попытка
			Стр = ФайлОтчета.ПрочитатьСтроку();
			Если Стр = Неопределено Тогда
				ФайлОтчета.Закрыть();
				Возврат Ложь;
			КонецЕсли;
			
			СтрокиФайла = Новый Массив;
			СтрокиФайла.Добавить(Стр);
			Пока Стр <> Неопределено Цикл
				Стр = ФайлОтчета.ПрочитатьСтроку();
				СтрокиФайла.Добавить(Стр);
			КонецЦикла;
			ФайлОтчета.Закрыть();
		Исключение
			ФайлОтчета.Закрыть();
			ВызватьИсключение;
		КонецПопытки;
		
		// надо ли выводить при ошибке
		Если СписокСтрокПоиска <> Неопределено Тогда
			Для Инд = 0 По СтрокиФайла.Количество()-1 Цикл
				СтрокаПроверки = ВРег(СтрокиФайла[Инд]);
				Для Каждого СтрПоиска Из СписокСтрокПоиска Цикл
					ВФразаПоиска = ВРег(СтрПоиска);
					Если СтрЧислоВхождений(СтрокаПроверки, ВФразаПоиска) <> 0 Тогда
						// не будем выводить
						Возврат Ложь;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
		
		// вывести если строки не нашлись
		текстФайла = "+---/ "+ИмяФайла+" /-------------------------------";
		Для Инд = 0 По СтрокиФайла.Количество()-1 Цикл
			текстФайла = текстФайла + "|"+СтрокиФайла[Инд];
		КонецЦикла;
		текстФайла = текстФайла + "+-------------";
		ВывестиСообщение(текстФайла);
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  ИмяФайлаРезультата – Краткое имя файла, в который будет выведен выходной поток, только в текущем каталоге.
//
Функция ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Знач СтрокаЗапуска, ТекущийКаталог = "\.", ИспользоватьWSH = Ложь,
	КраткоеИмяФайлаРезультата = "", ОжидатьЗавершения = Истина) Экспорт 

	//#Если Клиент Тогда
	//// Баг платформы здесь будет работать. Во время работы данной строки окно продолжает принимать команды! 
	//// WSH не использовать при генерации внешних обработок
	//Если ИспользоватьWSH Тогда
	//#КонецЕсли
		СтарыйТекущийКаталог = WshShell.CurrentDirectory;
		WshShell.CurrentDirectory = ТекущийКаталог;
		СтрокаЗапуска = "cmd.exe /c """ + СтрокаЗапуска + """";
		Если КраткоеИмяФайлаРезультата <> "" Тогда
			СтрокаЗапуска = СтрокаЗапуска + " > " + КраткоеИмяФайлаРезультата;
			СтрокаЗапуска = СтрокаЗапуска + " 2>&1"; //stderr
		КонецЕсли;
		Попытка
			рез = WshShell.Run(СтрокаЗапуска, 0, 1); //WshShell.Run(СтрокаЗапуска, 0, 1);
		Исключение
			// Для x64 ОС
			СтрокаЗапуска = "%windir%\Sysnative\" + СтрокаЗапуска;
			рез = WshShell.Run(СтрокаЗапуска, 0, 1); //WshShell.Run(СтрокаЗапуска, 0, 1);
		КонецПопытки;
		WshShell.CurrentDirectory = СтарыйТекущийКаталог;
	//#Если Клиент Тогда
	//Иначе
	//	ПолучитьИсполнительСкрытыхКомандСистемы();
	//	//КонечнаяСтрока = ИсполнительСкрытыхКомандСистемы + " /nowindow /wait /silent /D=""" + ТекущийКаталог + """ " + СтрокаЗапуска;
	//	КонечнаяСтрока = ИсполнительСкрытыхКомандСистемы + " /nowindow /wait /silent /D=""" + ТекущийКаталог + """ """ + СтрокаЗапуска + """";
	//	ЗапуститьПриложение(КонечнаяСтрока, , ОжидатьЗавершения);
	//КонецЕсли;
	//#КонецЕсли
	
	Возврат рез;
КонецФункции // ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения()


Процедура Sleep(чСекунд) Экспорт
	
	Приостановить(чСекунд * 1000);
	//Шел=Новый COMОбъект("WScript.Shell");
	//Шел.run("ping -n " + Формат(чСекунд, "ЧДЦ=0; ЧГ=") + " -w 2000 0.0.0.1",0,-1);
		//Шел.run("timeout /t 2",0,-1); //1 секунда
		//Шел.run("choice /t 2 /d y",0,-1); //1 секунда
		
		//Для Счетчик = 1 По чСекунд Цикл
		//		ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения("ping -n 2 127.0.0.1");
		//КонецЦикла; 
	
КонецПроцедуры

// Код решает проблему с багом:
// TODO иногда бывает баг параллельной работы: при одновременном запуске (с точностью до секунды) двух пакетных выгрузок один из запущенных процессов 1С зависает.
// а в итоге висит и обработчик 1C2Git. Для продолжения работы нужно удалить запущенный процесс.
// баг найден на 8.3.3.721
//
//	Для работы метода нужно наличие в конфигурации следующей константы:
// 		ВремяПоследнегоЗапускаКонфигуратора1СФоновымЗаданием, тип Дата (дата и время)
Функция МожноЗапускатьКонфигураторВПакетномРежиме(ЗадержкаСПоследнегоЗапуска = 5, КоличествоПопыток = 3) Экспорт
	// НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);
	
	// Блокировка = Новый БлокировкаДанных();
	// ЭлементБлокировки = Блокировка.Добавить("Константа.ВремяПоследнегоЗапускаКонфигуратора1СФоновымЗаданием");
	// ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
			
	// КонстантаУспешноОбновлена = Ложь;
	// СчИтераций = 1;
	// Пока Не КонстантаУспешноОбновлена И (КоличествоПопыток = 0 Или СчИтераций <= КоличествоПопыток) Цикл
		// Попытка
			// Блокировка.Заблокировать();
			
			// ВремяПоследнегоЗапускаКонфигуратора = Константы.ВремяПоследнегоЗапускаКонфигуратора1СФоновымЗаданием.Получить();
			// ПрошлоВремени = ТекущаяДата() - ВремяПоследнегоЗапускаКонфигуратора;
			// Если ЗадержкаСПоследнегоЗапуска > ПрошлоВремени Тогда
				// ВремяОжидания = ЗадержкаСПоследнегоЗапуска - ПрошлоВремени;
				// Sleep(ВремяОжидания);
			// КонецЕсли;
			
			// Константы.ВремяПоследнегоЗапускаКонфигуратора1СФоновымЗаданием.Установить(ТекущаяДата());
			
			// КонстантаУспешноОбновлена = Истина;
		// Исключение
			// Ошибка = ОписаниеОшибки();
			// ЗаписьЖурналаРегистрации("ПакетныйРежим", УровеньЖурналаРегистрации.Ошибка, , , Ошибка);
		// КонецПопытки;
		
		// СчИтераций = СчИтераций + 1;
	// КонецЦикла;
	
	// Если ТранзакцияАктивна() Тогда
		// Если КонстантаУспешноОбновлена Тогда
			// ЗафиксироватьТранзакцию();
		// Иначе
			// ОтменитьТранзакцию();
		// КонецЕсли;
	// КонецЕсли; 
	
	// Возврат КонстантаУспешноОбновлена;
	Возврат Истина;
КонецФункции

Функция ПолучитьПодстрокуКомандыЗапуска1С_БазаДанных(парамПутьКБазе)
	
	КлючПутьКБазе = " /F """ + парамПутьКБазе + """";
	Возврат КлючПутьКБазе;
	
	// Если 0 = Найти(НРег(парамПутьКБазе),"srvr") Тогда
		// лПутьКБазе = " /F """ + парамПутьКБазе + """";
	// Иначе
		// лИмяКластераСерверов = НСтр(парамПутьКБазе, "Srvr");
		// лИмяБазы = НСтр(парамПутьКБазе, "Ref");
		
		// лПутьКБазе = " /S """ + лИмяКластераСерверов + "\" + лИмяБазы + """";
	// КонецЕсли;
	// Возврат лПутьКБазе;
КонецФункции


Функция ПолучитьПодстрокуКомандыЗапуска1С_Платформа1С(путьИБ, версияПлатформыДляБазы = "")
	Если ПустаяСтрока(версияПлатформыДляБазы) Тогда
		лПутьПлатформы1С = ПолучитьПутьПлатформы1СПоПутиИБ(путьИБ);
	Иначе
		лПутьПлатформы1С = ПравильныйПутьКПлатформеПоВерсииПлатформы(версияПлатформыДляБазы); //Константы.ПутьКПлатформе1с.Получить()
	КонецЕсли; 

		файлПлатформы1С = Новый Файл(лПутьПлатформы1С);
		Проверить(файлПлатформы1С.Существует(), "Не установлен путь к платформе 1С: не найден файл <"+лПутьПлатформы1С+">");

	Возврат """"+лПутьПлатформы1С+"""";
КонецФункции

Функция ПолучитьПодстрокуКомандыЗапуска1С_Хранилище(парамПользовательХранилща, парамПарольХранилища)
	СтрокаЛогинаХранилища = "";
	Если ЗначениеЗаполнено(парамПользовательХранилща) Тогда
		СтрокаЛогинаХранилища = " /ConfigurationRepositoryN"""+парамПользовательХранилща 
							+ """ /ConfigurationRepositoryP"""+парамПарольХранилища+"""";
	КонецЕсли;
	Возврат СтрокаЛогинаХранилища;
КонецФункции

Функция ПолучитьСтрокуЛогинаКомандыЗапуска1С(Пользователь, Пароль)
	СтрокаЛогина = "";
	Если ЗначениеЗаполнено(Пользователь) Тогда
		СтрокаЛогина = ПолучитьПодстрокуКомандыЗапуска1С_ЛогинПароль(Пользователь, Пароль); 
			//СтрокаЛогина = " /N " + СтруктураПараметров.Пользователь
			//	+ " /P """ + СтруктураПараметров.Пароль + """";
	КонецЕсли;
	Возврат СтрокаЛогина;
КонецФункции

Функция ПолучитьПодстрокуКомандыЗапуска1С_ЛогинПароль(парамЛогин = "", парамПароль = "")
	СтрокаЛогина = "";
	Если ЗначениеЗаполнено(парамЛогин) Тогда
		СтрокаЛогина = " /N """ + парамЛогин
			+ """ /P """ + парамПароль + """";
	КонецЕсли;
	Возврат СтрокаЛогина;
КонецФункции

Процедура СохранитьРеквизитыИТабличныеЧасти (Объект, ИмяФайлаXML=Неопределено) //Экспорт
    // ОВСЯНКИН - код не используется
	// ФайлXML = Новый ЗаписьXML;
    // ФайлXML.ОткрытьФайл(ИмяФайлаXML);
    // ФайлXML.ЗаписатьОбъявлениеXML();
    // ФайлXML.ЗаписатьНачалоЭлемента("Root");
    // ФайлXML.ЗаписатьАтрибут("Объект",Объект.Метаданные().Имя);
// //Сохраняем реквизиты
    // Для Каждого Реквизит Из Объект.Метаданные().Реквизиты Цикл
        // ФайлXML.ЗаписатьНачалоЭлемента("Реквизит");
        // ФайлXML.ЗаписатьАтрибут("Имя", Реквизит.Имя);
        // ТипЗначения = ТипЗнч(Объект[Реквизит.Имя]);
        // Если Не ТипЗначения = Тип("Неопределено") Тогда
            // ФайлXML.ЗаписатьАтрибут("ИмяТипа", XMLТип(ТипЗначения).ИмяТипа);
            // ФайлXML.ЗаписатьАтрибут("URI", XMLТип(ТипЗначения).URIПространстваИмен);
        // КонецЕсли;
        // ФайлXML.ЗаписатьТекст(XMLСтрока(Объект[Реквизит.Имя]));
        // ФайлXML.ЗаписатьКонецЭлемента();
    // КонецЦикла;
// //Сохраняем табличные части
    // Для Каждого ТЧ из Объект.Метаданные().ТабличныеЧасти Цикл
        // ФайлXML.ЗаписатьНачалоЭлемента("ТабличнаяЧасть");
        // ФайлXML.ЗаписатьАтрибут("Имя", ТЧ.Имя);
        // Для Каждого СтрокаТЧ из Объект[ТЧ.Имя] Цикл
            // ФайлXML.ЗаписатьНачалоЭлемента("ЭлементКоллекции");
            // Для Каждого РеквизитТЧ Из ТЧ.Реквизиты Цикл
                // ФайлXML.ЗаписатьНачалоЭлемента("Реквизит");
                // ФайлXML.ЗаписатьАтрибут("Имя", РеквизитТЧ.Имя);
                // ТипЗначения = ТипЗнч(СтрокаТЧ[РеквизитТЧ.Имя]);
                // Если Не ТипЗначения = Тип("Неопределено") Тогда
                    // ФайлXML.ЗаписатьАтрибут("ИмяТипа", XMLТип(ТипЗначения).ИмяТипа);
                    // ФайлXML.ЗаписатьАтрибут("URI", XMLТип(ТипЗначения).URIПространстваИмен);
                // КонецЕсли;
                // ФайлXML.ЗаписатьТекст(XMLСтрока(СтрокаТЧ[РеквизитТЧ.Имя]));
                // ФайлXML.ЗаписатьКонецЭлемента();
            // КонецЦикла;
            // ФайлXML.ЗаписатьКонецЭлемента();
        // КонецЦикла;
        // ФайлXML.ЗаписатьКонецЭлемента();
    // КонецЦикла;
	// // ОВСЯНКИН - всегда Истинное условие, но литерал Null не поддерживается oscript
    // //Если Не ФайлXML=Null Тогда
        // ФайлXML.ЗаписатьКонецЭлемента();
        // ФайлXML.Закрыть();
    // //КонецЕсли;
КонецПроцедуры

Процедура ЗагрузитьРеквизитыИТабличныеЧасти(Объект, ИмяФайлаXML=Неопределено) //Экспорт
    // Если Не ИмяФайлаXML = Неопределено Тогда
        // ФайлXML = Новый ЧтениеXML;
        // ФайлXML.ОткрытьФайл(ИмяФайлаXML);
        // Пока ФайлXML.Прочитать() Цикл
            // Если ФайлXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
                // ЗагрузитьОбъектРекурсивно(ФайлXML, Объект, ФайлXML.Имя);
            // КонецЕсли
        // КонецЦикла;
    // КонецЕсли;
КонецПроцедуры

Процедура ЗагрузитьОбъектРекурсивно(ФайлXML, Объект, знач ИмяУзла)
    // ИмяТипа = "";
    // ПространствоИмен = "";
    // Пока ФайлXML.ПрочитатьАтрибут() Цикл
        // Если ФайлXML.Имя = "ИмяТипа" Тогда
            // ИмяТипа = ФайлXML.Значение;
        // ИначеЕсли ФайлXML.Имя = "URI" Тогда
            // ПространствоИмен = ФайлXML.Значение;
        // КонецЕсли;
    // КонецЦикла;
    // Пока ФайлXML.Прочитать() Цикл
        // Если ФайлXML.ТипУзла = ТипУзлаXML.КонецЭлемента И ФайлXML.Имя = ИмяУзла Тогда
            // Возврат;
        // ИначеЕсли ФайлXML.ТипУзла = ТипУзлаXML.Текст Тогда
            // ТипОбъекта = ИзXMLТипа(ИмяТипа, ПространствоИмен);
            // Если НЕ ТипОбъекта = Неопределено тогда
                // Объект = XMLЗначение(ТипОбъекта, ФайлXML.Значение);
            // КонецЕсли;
        // ИначеЕсли ФайлXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
            // ИмяТекУзла = ФайлXML.Имя;
            // Если ФайлXML.Имя = "ЭлементКоллекции" Тогда
                // ЗагрузитьОбъектРекурсивно(ФайлXML, Объект.Добавить(), ИмяТекУзла);
            // Иначе
                // Если ФайлXML.ПрочитатьАтрибут() Тогда
                    // ЗагрузитьОбъектРекурсивно(ФайлXML, Объект[ФайлXML.Значение], ИмяТекУзла);
                // КонецЕсли;
            // КонецЕсли;
        // КонецЕсли;
    // КонецЦикла;
КонецПроцедуры

Процедура ОбработатьПараметрыЗапуска(ПараметрЗапуска, СтруктураПараметров = Неопределено) Экспорт
	Перем Путь;
	Перем ВыгрузитьДанные, ЗагрузитьДанные, мАвтозапуск, ПутьКФайлуЛогов, ПутьКХранилищу1C;
	Перем МаксимальнаяВерсияРазбора;
	
	Если ПустаяСтрока(ПараметрЗапуска) Тогда
		Возврат ;
	КонецЕсли;
	
	ВыгрузитьДанные					= Ложь;
	ЗагрузитьДанные					= Ложь;
	СинхронизироватьХранилищеВГит	= Ложь;
	мАвтозапуск						= Ложь;
	ПутьКФайлуЛогов					= "";
	РабочийКаталог					= "";

	
	Если Не ЗначениеЗаполнено(СтруктураПараметров) Тогда
		СтруктураПараметров = Новый Структура;//("КаталогВыгрузки", КаталогВыгрузки);
	КонецЕсли; 
	
	// Параметр может состоять из частей, разделенных символом ";".
	// Первая часть - главное значение параметра запуска. 
	// Наличие дополнительных частей определяется логикой обработки главного параметра.
	МассивПараметрыЗапуска = РазложитьСтрокуВМассивПодстрок(ПараметрЗапуска,";");
	Для Номер = 0 По МассивПараметрыЗапуска.Количество()-1 Цикл
		ЭлементМассива = МассивПараметрыЗапуска.Получить(Номер);
		Если ВРег(ЭлементМассива) = ВРег("path83") И Номер+1<=МассивПараметрыЗапуска.Количество()-1 Тогда
			Путь = МассивПараметрыЗапуска.Получить(Номер+1);
			Файл = Новый Файл(Путь);
			Если НЕ Файл.Существует() ИЛИ НЕ Файл.ЭтоФайл() Тогда
				ПутьКПлатформе1с83 = ПолучитьПутьПлатформы1С_83();
			Иначе
				ПутьКПлатформе1с83 = Путь;
			КонецЕсли;
		ИначеЕсли ВРег(ЭлементМассива) = ВРег("pathToCF") И Номер+1<=МассивПараметрыЗапуска.Количество()-1 Тогда
			Путь = МассивПараметрыЗапуска.Получить(Номер+1);
			ПутьКФайлуКонфигурации = Путь;
			СтруктураПараметров.Вставить("ПутьКФайлуКонфигурации", ПутьКФайлуКонфигурации);
				//Файл = Новый Файл(Путь);
				//Если НЕ Файл.Существует() ИЛИ НЕ Файл.ЭтоФайл() Тогда
				//	ПутьКФайлуКонфигурации = "";
				//Иначе
				//	ПутьКФайлуКонфигурации = Путь;
				//КонецЕсли;
				//СтруктураПараметров.Вставить("ПутьКФайлуКонфигурации", ПутьКФайлуКонфигурации);
			
		ИначеЕсли ВРег(ЭлементМассива) = ВРег("pathOut") И Номер+1<=МассивПараметрыЗапуска.Количество()-1 Тогда
			
			Путь = МассивПараметрыЗапуска.Получить(Номер+1);
			КаталогВыгрузки = Путь; //ПутьККаталогуДляВыгрузки
			Файл = Новый Файл(Путь);
			Если НЕ Файл.Существует() ИЛИ НЕ Файл.ЭтоКаталог() Тогда
				Попытка
					СоздатьКаталог(Путь); // TODO нужно ли удалять каталог ??
					//КаталогВыгрузки = Путь; //ПутьККаталогуДляВыгрузки
				Исключение
					//КаталогВыгрузки = ""; //ПутьККаталогуДляВыгрузки
				КонецПопытки;
			//Иначе
			//	КаталогВыгрузки = Путь; //ПутьККаталогуДляВыгрузки
			КонецЕсли;
			СтруктураПараметров.Вставить("КаталогВыгрузки", ДополнитьСлешВПуть(КаталогВыгрузки));
			
		ИначеЕсли ВРег(ЭлементМассива) = ВРег("pathRepo") И Номер+1<=МассивПараметрыЗапуска.Количество()-1 Тогда
			
			Путь = МассивПараметрыЗапуска.Получить(Номер+1);
			ПутьКХранилищу1C = Путь; //ПутьККаталогуДляВыгрузки
				//Файл = Новый Файл(Путь);
				//Если НЕ Файл.Существует() Тогда
				//	ПутьКХранилищу1C = ""; //ПутьККаталогуДляВыгрузки
				//Иначе
				//	ПутьКХранилищу1C = Файл.ПолноеИмя; //ПутьККаталогуДляВыгрузки
				//КонецЕсли;
			СтруктураПараметров.Вставить("ПутьКХранилищу1C", ПутьКХранилищу1C); // TODO это разные объекты - здесь каталог
			СтруктураПараметров.Вставить("ПутьКФайлуХранилища1С", ПутьКХранилищу1C); // TODO это разные объекты - а вот здесь файл
		ИначеЕсли ВРег(ЭлементМассива) = ВРег("maxVersions") И Номер+1<=МассивПараметрыЗапуска.Количество()-1 Тогда
			МаксимальнаяВерсияРазбора = МассивПараметрыЗапуска.Получить(Номер+1);
		ИначеЕсли ВРег(ЭлементМассива) = ВРег("pathTemp") И Номер+1<=МассивПараметрыЗапуска.Количество()-1 Тогда
			
			РабочийКаталог = МассивПараметрыЗапуска.Получить(Номер+1);
			
		КонецЕсли;
		
		Если ВРег(ЭлементМассива) = ВРег("auto") Тогда
			мАвтозапуск = Истина;
		КонецЕсли;
		
		Если ВРег(ЭлементМассива) = ВРег("decompile") Тогда
			ВыгрузитьДанные = Истина;
		КонецЕсли;
		
		Если ВРег(ЭлементМассива) = ВРег("compile") Тогда
			ЗагрузитьДанные = Истина;
		КонецЕсли;
		
		Если ВРег(ЭлементМассива) = ВРег("sync1ctogit") Тогда
			СинхронизироватьХранилищеВГит = Истина;
		КонецЕсли;
		
		Если ВРег(ЭлементМассива) = ВРег("out") Тогда
			
			Путь = УбратьОбрамляющиеКавычкиЕслиЕсть(МассивПараметрыЗапуска.Получить(Номер+1));
			ПутьКФайлуЛогов = Путь;
			
		КонецЕсли;
		
		
	КонецЦикла;
	
	Инициализация();
	
	// #Если ТолстыйКлиентОбычноеПриложение Тогда
		// ЗаписатьОшибкуВЛог(ПутьКФайлуЛогов, 1);
	// #КонецЕсли
	
	Если ВыгрузитьДанные Тогда
		
		//лКаталогВыгрузки = "";
		лИмяКаталогаБазы = "";
		успешно = РазложитьКонфигурацию1СПоПапкамСогласноИерархииМетаданных("", "", ПутьКФайлуКонфигурации, КаталогВыгрузки, лИмяКаталогаБазы);
		СтруктураПараметров.Вставить("ПутьКGit", КаталогВыгрузки); //СтруктураПараметров.КаталогВыгрузки);
		
		Проверить(успешно, "РазложитьКонфигурацию1СПоПапкамСогласноИерархииМетаданных");
		//Проверить(РазложитьКонфигурацию1СПоПапкамСогласноИерархииМетаданных(СтруктураПараметров), "РазложитьКонфигурацию1СПоПапкамСогласноИерархииМетаданных");
	
	ИначеЕсли ЗагрузитьДанные = Истина Тогда
		
		Если СтруктураПараметров.Свойство("КаталогВыгрузки") Тогда
			СтруктураПараметров.Вставить("КаталогЗагрузки", СтруктураПараметров.КаталогВыгрузки);
		КонецЕсли;

		Проверить(СобратьКонфигурацию1СПоПапкамСогласноИерархииМетаданных(СтруктураПараметров), "СобратьКонфигурацию1СПоПапкамСогласноИерархииМетаданных");	
		
	ИначеЕсли СинхронизироватьХранилищеВГит = Истина Тогда
		
		СтруктураПараметров.Вставить("МаксимальнаяВерсия", МаксимальнаяВерсияРазбора);
		Проверить(СинхронизироватьХранилищеКонфигурацийСГит(СтруктураПараметров), "СинхронизироватьХранилищеКонфигурацийСГит");
		
	КонецЕсли;
	
		
КонецПроцедуры
 
Функция ПолучитьПутьКНовойБазе1С(папкаДляСозданияБазыПоУмолчанию = "")
	Если НЕ ЗначениеЗаполнено(папкаДляСозданияБазыПоУмолчанию) Тогда
		лИмяКаталога = ПолучитьВременноеИмяКаталога(); //СтрЗаменить(_ПолучитьИмяВременногоФайла("сtr"), ".сtr", "");
			//лПутьФайла = _ПолучитьИмяВременногоФайла();
			//лФайл = Новый Файл(лПутьФайла);
			//
			//лИмяКаталога = лФайл.Путь + лФайл.ИмяБезРасширения;
	Иначе
		лИмяКаталога = папкаДляСозданияБазыПоУмолчанию;
	КонецЕсли;
	
	лКаталог = Новый Файл(лИмяКаталога);
	Если лКаталог.Существует() Тогда
		Попытка
			УдалитьФайлы(лИмяКаталога);
		Исключение
		    ошибка = ОписаниеОшибки();
			ВызватьИсключение "Не удалось удалить папку для новой тестовой базы"; 
		КонецПопытки; 
	КонецЕсли; 
	
	СоздатьКаталог(лИмяКаталога); // TODO нужно ли удалять каталог?? изучить вызовы метода
	Проверить(лКаталог.Существует(), "Не удалось создать папку для новой тестовой базы");
	
	Возврат лИмяКаталога;
КонецФункции

////////////////////////////////////////////
// Работа с временными файлами
 
Процедура ЗарегистрироватьВременныйФайл(Знач ПутьФайла)
	
	Если мКонтекстВыполнения.ВременныеФайлы.Найти(ПутьФайла) = Неопределено Тогда
		мКонтекстВыполнения.ВременныеФайлы.Добавить(ПутьФайла);	
	КонецЕсли;
	
КонецПроцедуры

Процедура УдалитьЗарегистрированныеВременныеФайлы() Экспорт
	Если мКонтекстВыполнения.ВременныеФайлы = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	ВсегоФайлов = мКонтекстВыполнения.ВременныеФайлы.Количество();
	Для Сч = 0 По ВсегоФайлов-1 Цикл
		
		Индекс = ВсегоФайлов-Сч;
		ИмяВременногоФайла = мКонтекстВыполнения.ВременныеФайлы[Индекс];
		Если БезопасноУдалитьВременныйФайл(ИмяВременногоФайла) Тогда
			ВывестиСообщение("Удален файл/папка " + ИмяВременногоФайла);
			мКонтекстВыполнения.ВременныеФайлы.Удалить(Индекс);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры
 
Функция БезопасноУдалитьВременныйФайл(Путь)
	 
	Попытка
		УдалитьФайлы(Путь);
		Возврат Истина;
	Исключение
		Ошибка = "Попытка удаления "+Путь+" закончилась неудачей, по причине "+ОписаниеОшибки();
		УдаляемыйФайл = Новый Файл(Путь);
		Если УдаляемыйФайл.ЭтоФайл() и УдаляемыйФайл.ПолучитьТолькоЧтение() Тогда
			УдаляемыйФайл.УстановитьТолькоЧтение(ложь);
			Попытка
				УдалитьФайлы(Путь);
				Возврат Истина;
			Исключение
				ВывестиСообщение(ошибка);
			 КонецПопытки;
		Иначе
			ВывестиСообщение(ошибка);
		КонецЕсли; 
	КонецПопытки;

	Возврат Ложь;
КонецФункции

// Функция разбивает строку разделителем.
//
// Подсистема "Инструменты разработчика"  Авторское право (с) 2007, Старых С.А.
// 
// Параметры:
//  пСтрока      - Строка - которую разбиваем;
//  *пРазделитель - Строка, "." - символ-разделитель;
//  *ОбрезатьНепечатныеСимволы - Булево, *Ложь - делать СокрЛП.
//  *ОставлятьПустуюСтроку - Булево, *Истина - если передана пустая строка, то добавлять ее в массив.
//
// Возвращаемое значение:
//  Массив - фрагментов.
//
Функция ПолучитьМассивИзСтрокиСРазделителем(Знач Стр, Разделитель = ".", ОбрезатьНепечатныеСимволы = Ложь, ОставлятьПустуюСтроку = Истина) Экспорт
	
	ВывестиСообщение("Процедура на удаление");
	
	МассивСтрок = Новый Массив;
	Если Истина
		И Не ОставлятьПустуюСтроку 
		И ПустаяСтрока(Стр)
	Тогда
		Возврат МассивСтрок;
	КонецЕсли; 
	
	//лСтрока = СтрЗаменить(Стр, Разделитель, Символы.ПС);
	//// Баг платформы. СтрЧислоСтрок не учитывает терминальный перевод строки.
	//ЧислоСтрок = СтрЧислоСтрок(лСтрока + " ");
	//Для Счетчик = 1 По ЧислоСтрок Цикл 
	//	Фрагмент = СтрПолучитьСтроку(лСтрока, Счетчик);
	//	Если ОбрезатьНепечатныеСимволы Тогда
	//		Фрагмент = СокрЛП(Фрагмент);
	//	КонецЕсли;
	//	МассивСтрок.Добавить(Фрагмент);
	//КонецЦикла;
	
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				Фрагмент = Стр;
				Если ОбрезатьНепечатныеСимволы Тогда
					Фрагмент = СокрЛП(Фрагмент);
				КонецЕсли;
				МассивСтрок.Добавить(Фрагмент);
				Возврат МассивСтрок;
			КонецЕсли;
			Фрагмент = Лев(Стр,Поз-1);
			Если ОбрезатьНепечатныеСимволы Тогда
				Фрагмент = СокрЛП(Фрагмент);
			КонецЕсли;
			МассивСтрок.Добавить(Фрагмент);
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;

	Возврат МассивСтрок;
		
КонецФункции // ПолучитьМассивИзСтрокиСРазделителем()

// Разбивает строку на несколько строк по разделителю. Разделитель может иметь любую длину.
// Общий модуль СтроковыеФункцииКлиентСервер.
//
// Параметры:
//  Строка                 - Строка - текст с разделителями;
//  Разделитель            - Строка - разделитель строк текста, минимум 1 символ;
//  ПропускатьПустыеСтроки - Булево - признак необходимости включения в результат пустых строк.
//    Если параметр не задан, то функция работает в режиме совместимости со своей предыдущей версией:
//     - для разделителя-пробела пустые строки не включаются в результат, для остальных разделителей пустые строки
//       включаются в результат.
//     - если параметр Строка не содержит значащих символов или не содержит ни одного символа (пустая строка), то в
//       случае разделителя-пробела результатом функции будет массив, содержащий одно значение "" (пустая строка), а
//       при других разделителях результатом функции будет пустой массив.
//
//
// Возвращаемое значение:
//  Массив - массив строк.
//
// Примеры:
//  РазложитьСтрокуВМассивПодстрок(",один,,два,", ",") - возвратит массив из 5 элементов, три из которых  - пустые строки;
//  РазложитьСтрокуВМассивПодстрок(",один,,два,", ",", Истина) - возвратит массив из двух элементов;
//  РазложитьСтрокуВМассивПодстрок(" один   два  ", " ") - возвратит массив из двух элементов;
//  РазложитьСтрокуВМассивПодстрок("") - возвратит пустой массив;
//  РазложитьСтрокуВМассивПодстрок("",,Ложь) - возвратит массив с одним элементом "" (пустой строкой);
//  РазложитьСтрокуВМассивПодстрок("", " ") - возвратит массив с одним элементом "" (пустой строкой);
//
//&НаКлиенте
Функция РазложитьСтрокуВМассивПодстрок(Знач Строка, Знач Разделитель = ",", Знач ПропускатьПустыеСтроки = Неопределено) Экспорт
	
	Результат = Новый Массив;
	
	// для обеспечения обратной совместимости
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = " ", Истина, Ложь);
		Если ПустаяСтрока(Строка) Тогда 
			Если Разделитель = " " Тогда
				Результат.Добавить("");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Строка) Тогда
		Результат.Добавить(Строка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

Процедура ВывестиСообщение(сообщение) Экспорт
	ВывестиСообщениеИлиОшибку(сообщение, Ложь);
КонецПроцедуры

Процедура ВывестиОшибку(сообщение) Экспорт
	ВывестиСообщениеИлиОшибку(сообщение, Истина);
КонецПроцедуры

Процедура ВывестиСообщениеИлиОшибку(Знач Сообщение, Знач ЭтоОшибка) Экспорт
	Сообщить(Сообщение);
	
	// Если ВыводитьСообщенияВЖурналРегистрации Тогда
		// ЗаписьЖурналаРегистрации("1C2Git", ?(ошибка, УровеньЖурналаРегистрации.Ошибка, УровеньЖурналаРегистрации.Информация), , , сообщение);
	// КонецЕсли; 

КонецПроцедуры

Процедура ВывестиОтладочноеСообщение(сообщение) Экспорт
	Если ВключенРежимОтладки или ВыводитьСообщенияВЖурналРегистрации Тогда
		ВывестиСообщение(сообщение);
	КонецЕсли;	
КонецПроцедуры

Функция ЭтоФайловаяБаза(путьКБазе) Экспорт 

	Префикс = ВРЕГ(Лев(ПутьКБазе,5));
	Возврат Префикс = "FILE=";
	//ИмяКластераСерверов = НСтр(путьКБазе, "Srvr");
	//ЭтоФайловаяБаза = ПустаяСтрока(ИмяКластераСерверов);
	//Возврат ЭтоФайловаяБаза;

КонецФункции // ЭтоФайловаяБазаИис()

Функция УбратьОбрамляющиеКавычкиЕслиЕсть(текст) Экспорт
	лЗначение = текст;
	Если Лев(лЗначение, 1) = """" Тогда
		лЗначение = Сред(лЗначение, 2);
	КонецЕсли;
	Если Прав(лЗначение, 1) = """" Тогда
		лЗначение = Сред(лЗначение, 1, СтрДлина(лЗначение)-1);
	КонецЕсли;
	Возврат лЗначение;
КонецФункции

Функция ФорматДСО(ДопСообщениеОшибки)
	Если ДопСообщениеОшибки = "" Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат Символы.ПС + ДопСообщениеОшибки;
КонецФункции

Процедура Проверить(Знач УсловиеВерно, ДопСообщениеОшибки = "") //Экспорт
	СообщениеОшибки = "Переданный параметр ("+УсловиеВерно+") не является Истиной, а хотели, чтобы являлся." + ФорматДСО(ДопСообщениеОшибки);
	
	Если Не УсловиеВерно Тогда
		ВызватьИсключение(СообщениеОшибки);
	КонецЕсли;
КонецПроцедуры

Процедура ИниФайлСтруктура_Добавить(ИниФайлСтруктура, Группа, Ключ, Значение);
	Отбор = Новый Структура;
	Отбор.Вставить("Группа", Группа);
	Отбор.Вставить("Ключ", Ключ);
	НайденныеСтроки = ИниФайлСтруктура.НайтиСтроки(Отбор);
	Если НайденныеСтроки.Количество() = 0 Тогда
		СтрИниФайлСтруктура = ИниФайлСтруктура.Добавить();
		СтрИниФайлСтруктура.Группа = Группа;
		СтрИниФайлСтруктура.Ключ = Ключ;
		СтрИниФайлСтруктура.Значение = Значение;
	Иначе
		НайденныеСтроки[0].Значение = Значение;
	КонецЕсли;
КонецПроцедуры

// Функция ДополнитьСлешВПуть
//
// Параметры:
// ИмяКаталога
//
// Описание:
// Функция дополняет и возвращает слеш в путь в конец строки, если он отсутствует
//
Функция ДополнитьСлешВПуть(Знач Каталог)
	Если Прав(Каталог, 1) <> "\" Тогда
		Каталог = Каталог + "\";
	КонецЕсли;
	Возврат Каталог;
КонецФункции

//Возвращает Рабочий каталог обработки: если он не был задан при инициализации, то "КаталогВременныхФайлов"
Функция КаталогРабочихФайлов()
	
	Если Не ЗначениеЗаполнено(мПараметры.РабочийКаталог) Тогда
		мПараметры.РабочийКаталог = КаталогВременныхФайлов();
	КонецЕсли;
	
	Возврат мПараметры.РабочийКаталог;
	
КонецФункции


// ======================= КОНЕЦ ОСНОВНОГО БЛОКА ======================= =========================
//
//} ======================= ======================= ======================= =======================


//{ ======================= БЛОК ЮНИТ-ТЕСТОВ - сами тесты ========================================
//
// ======================= ======================= ======================= ======================= 
Процедура ПередЗапускомТеста() Экспорт
	_тестируем = Истина;
	ВключенРежимОтладки = Истина;
	
	СоздатьМассивВременныхПутейЕслиОнЕщеНеСоздан();
	
	//юТест.ВывестиСообщение("Перед запуском теста");
	_тест_СтруктураПараметров = Неопределено;
КонецПроцедуры

Процедура ПослеЗапускаТеста() Экспорт
	
	//юТест.ВывестиСообщение("После запуска теста");
	_тест_СтруктураПараметров = Неопределено;
	
	УдалитьВременныйФайлКонфигурации();
	
	УдалитьЗарегистрированныеВременныеФайлы();
	
	_тестируем = Ложь;	
КонецПроцедуры

Процедура Тест_ДолженВыполнитьПолнуюВыгрузкуЧерезПараметрыЗапуска() Экспорт
	лПутьКФайлуКонфигурации = ПолучитьФайлКонфигурацииИзМакета();

	//_тест_СтруктураПараметров = Новый Структура;
	//_тест_СтруктураПараметров.Вставить("ПутьКФайлуКонфигурации", лПутьКФайлуКонфигурации);
	
	лКаталогВыгрузки = ПолучитьВременноеИмяКаталога(); //СтрЗаменить(_ПолучитьИмяВременногоФайла("сtr"), ".сtr", "");
	
	_тест_СтруктураПараметров = Неопределено;
		//Строка = "pathToCF;"+лПутьКФайлуКонфигурации+";patchOut;"+лКаталогВыгрузки+";decompile;";	
		//ОбработатьПараметрыЗапуска(Строка, _тест_СтруктураПараметров);
	РазобратьФайлКонфигурации(лПутьКФайлуКонфигурации, лКаталогВыгрузки, _тест_СтруктураПараметров);
	
	МассивФайлов = НайтиФайлы(_тест_СтруктураПараметров.ПутьКGit,"*.*");
		юТест.ПроверитьИстину(МассивФайлов.Количество() > 0, "в каталоге разложения модулей 1С <"+_тест_СтруктураПараметров.КаталогВыгрузки+"> должны быть файлы");
КонецПроцедуры
 
Процедура Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации() Экспорт
	лИмяКаталогаБазы = "";
	_Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации(лИмяКаталогаБазы);
	_тест_СтруктураПараметров.Вставить("ИмяКаталогаБазы", лИмяКаталогаБазы);
КонецПроцедуры

Процедура Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации_Платформа82() Экспорт
	лИмяКаталогаБазы = "";
	_Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации(лИмяКаталогаБазы, "ТестовыйФайлКонфигурации_8_2_17");
	_тест_СтруктураПараметров.Вставить("ИмяКаталогаБазы", лИмяКаталогаБазы);
КонецПроцедуры

Процедура _Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации(резИмяКаталогаБазы, имяМакета = "") Экспорт
	ПутьКПлатформе1с83 = ПолучитьПутьПлатформы1С_83();
	
	лПутьКФайлуКонфигурации = ПолучитьФайлКонфигурацииИзМакета(имяМакета);
	
	_тест_СтруктураПараметров = Новый Структура;
		//		//СтруктураПараметров = Новый Структура("ПутьКДанным, ПутьКБазе, КаталогВыгрузки", ПутьКДанным, ПутьКБазе, _тест_ПутьКФайлуКонфигурации);
		//_тест_СтруктураПараметров.Вставить("ПутьКФайлуКонфигурации", лПутьКФайлуКонфигурации);
	
	лИмяКаталогаБазы = "";
	успешно = СоздатьПустуюБазу(лПутьКФайлуКонфигурации, лИмяКаталогаБазы); //СоздатьПустуюБазу(_тест_СтруктураПараметров);
		юТест.ПроверитьИстину(успешно, "создание пустой базы по cf");
	_тест_СтруктураПараметров.Вставить("ИмяКаталогаБазы", лИмяКаталогаБазы);
		
	лФайлБазы = Новый Файл(лИмяКаталогаБазы+"\1cv8.1cd"); //	лФайлБазы = Новый Файл(_тест_СтруктураПараметров.ИмяКаталогаБазы+"\1cv8.1cd");
		юТест.ПроверитьИстину(лФайлБазы.Существует(), "Не создана новая база 1С - не существует файл новой базы <"+лИмяКаталогаБазы+"\1cv8.1cd>");
		//юТест.ПроверитьИстину(лФайлБазы.Существует(), "Не создана новая база 1С - не существует файл новой базы <"+_тест_СтруктураПараметров.ИмяКаталогаБазы+"\1cv8.1cd>");
	резИмяКаталогаБазы = лИмяКаталогаБазы;
КонецПроцедуры

Процедура Тест_ДолженВыгрузитьМодули() Экспорт 
	Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации();		
	
	лКаталогВыгрузкиВсехМодулей83 = "";
	
	успешно = ВыгрузитьМодули(_тест_СтруктураПараметров.ИмяКаталогаБазы, "", "", лКаталогВыгрузкиВсехМодулей83);
			//успешно = ВыгрузитьМодули(_тест_СтруктураПараметров.ИмяКаталогаБазы, _тест_СтруктураПараметров.Пользователь, _тест_СтруктураПараметров.Пароль, лКаталогВыгрузкиВсехМодулей83);
		юТест.ПроверитьИстину(успешно, "выгрузить модули 1С");
	_тест_СтруктураПараметров.Вставить("КаталогВыгрузкиВсехМодулей83", лКаталогВыгрузкиВсехМодулей83);
		
	МассивФайлов = НайтиФайлы(лКаталогВыгрузкиВсехМодулей83,"*.*");
		юТест.ПроверитьИстину(МассивФайлов.Количество() > 0, "в каталоге выгрузки модулей 1С <"+лКаталогВыгрузкиВсехМодулей83+"> должны быть файлы");
КонецПроцедуры

Процедура Тест_ДолженРазложитьМодули1СПоПапкамСогласноИерархииМетаданных() Экспорт 
	Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации();		
	Тест_ДолженВыгрузитьМодули();
	
	лПутьКаталогаВыгрузкиДанных = ПолучитьВременноеИмяКаталога(); //СтрЗаменить(_ПолучитьИмяВременногоФайла("сtr"), ".сtr", "");
	_тест_СтруктураПараметров.Вставить("КаталогВыгрузки", лПутьКаталогаВыгрузкиДанных);
	
	успешно = РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(_тест_СтруктураПараметров.КаталогВыгрузкиВсехМодулей83, лПутьКаталогаВыгрузкиДанных);
	
	юТест.ПроверитьИстину(успешно, "РазложитьМодули1СПоПапкамСогласноИерархииМетаданных");
	_тест_СтруктураПараметров.Вставить("ПутьКGit", лПутьКаталогаВыгрузкиДанных);
		
	лФайл = Новый Файл(лПутьКаталогаВыгрузкиДанных + "\renames.txt");
	юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось разложим модули 1С по иерархии - не существует файл <"+лФайл.ПолноеИмя+">");
		
	МассивФайлов = НайтиФайлы(лПутьКаталогаВыгрузкиДанных,"*.*");
	юТест.ПроверитьИстину(МассивФайлов.Количество() > 0, "в каталоге разложения модулей 1С <"+лПутьКаталогаВыгрузкиДанных+"> должны быть файлы");
КонецПроцедуры

Процедура Тест_ДолженРазложитьМодули1СПоПапкамСогласноИерархииМетаданных_Платформа82() Экспорт 
	Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации_Платформа82();		
	Тест_ДолженВыгрузитьМодули();
	
	лПутьКаталогаВыгрузкиДанных = ПолучитьВременноеИмяКаталога(); //СтрЗаменить(_ПолучитьИмяВременногоФайла("сtr"), ".сtr", "");
	_тест_СтруктураПараметров.Вставить("КаталогВыгрузки", лПутьКаталогаВыгрузкиДанных);
	
	успешно = РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(_тест_СтруктураПараметров.КаталогВыгрузкиВсехМодулей83, лПутьКаталогаВыгрузкиДанных);
	//	ВывестиСообщение("Не удалось выполнить копирование файлов");
	//	Возврат Ложь;
	//КонецЕсли; 
	
	//успешно = РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(_тест_СтруктураПараметров);
		юТест.ПроверитьИстину(успешно, "РазложитьМодули1СПоПапкамСогласноИерархииМетаданных");
	_тест_СтруктураПараметров.Вставить("ПутьКGit", лПутьКаталогаВыгрузкиДанных);
		
	лФайл = Новый Файл(лПутьКаталогаВыгрузкиДанных + "\renames.txt");
		юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось разложим модули 1С по иерархии - не существует файл <"+лФайл.ПолноеИмя+">");
		
	МассивФайлов = НайтиФайлы(лПутьКаталогаВыгрузкиДанных,"*.*");
		юТест.ПроверитьИстину(МассивФайлов.Количество() > 0, "в каталоге разложения модулей 1С <"+лПутьКаталогаВыгрузкиДанных+"> должны быть файлы");
КонецПроцедуры

Процедура Тест_ДолженСоздатьПустуюБазуБезШаблона()
	
	ПутьКПлатформе1с83 = ПолучитьПутьПлатформы1С_83();
	
	//_тест_СтруктураПараметров = Новый Структура();
	успешно = СоздатьПустуюБазуБезШаблона(_тест_СтруктураПараметров);
	юТест.ПроверитьИстину(успешно, "Создание пустой базы, без шаблонов");
	
КонецПроцедуры

 Процедура _Тест_СобратьИзИерархииВЛинейнуюСтруктуру()
	
	юТест.ПроверитьИстину(_тест_СтруктураПараметров.Свойство("ПутьКGit"), "Не найден путь к каталогу выгрузки");
	_тест_СтруктураПараметров.Вставить("КаталогЗагрузки", _тест_СтруктураПараметров.ПутьКGit);
	успешно = СобратьМодули1СИзИерарархииМетаданныхВЛинейнуюСтруктуру(_тест_СтруктураПараметров);
	
	юТест.ПроверитьИстину(успешно, "Собрать из иерархии в линейную структуру");
	
	МассивФайлов = НайтиФайлы(_тест_СтруктураПараметров.ПутьКВременномуКаталогуПереименований,"*.*");
	юТест.ПроверитьИстину(МассивФайлов.Количество() > 0, "в каталоге линейной структуры модулей 1С <"+_тест_СтруктураПараметров.ПутьКВременномуКаталогуПереименований+"> должны быть файлы");
	
КонецПроцедуры

Процедура _Тест_ЗагрузитьМодулиКонфигурации() Экспорт
	
	юТест.ПроверитьИстину(_тест_СтруктураПараметров.Свойство("ПутьКВременномуКаталогуПереименований"), "Не найден путь к каталогу с xml выгрузкой");
	успешно = ЗагрузитьМодули(_тест_СтруктураПараметров);
		юТест.ПроверитьИстину(успешно, "Загрузка модулей не выполнена");
	
КонецПроцедуры


Процедура _Тест_СохранитьКонфигурациюВФайл() //Экспорт
	
		юТест.ПроверитьИстину(_тест_СтруктураПараметров.Свойство("ИмяКаталогаБазы"), "Не найден путь к каталогу с xml выгрузкой");
	_тест_СтруктураПараметров.Вставить("ПутьКФайлуКонфигурации", _ПолучитьИмяВременногоФайла(".cf"));;
	
	успешно = СохранитьКонфигурациюИзБазы(_тест_СтруктураПараметров.ПутьКФайлуКонфигурации, _тест_СтруктураПараметров.ИмяКаталогаБазы);
		юТест.ПроверитьИстину(успешно, "Загрузка модулей не выполненна");
	
	лФайл = Новый Файл(_тест_СтруктураПараметров.ПутьКФайлуКонфигурации);
		юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось сохранить cf  - не существует файл <"+лФайл.ПолноеИмя+">");
	
КонецПроцедуры

// TODO тест не работает, т.к. метод _Тест_СобратьИзИерархииВЛинейнуюСтруктуру собирает из временного
// каталога (пустого), а не из того каталога, в котором лежат XML файлы конфигурации
Процедура Тест_ДолженСобратьМодули1СИзПапокСогласноИерархииВОднуЛинейнуюПапку() Экспорт 
	/////////////////////
	// Отключение теста
	Возврат;
	/////////////////////
	
	Тест_ДолженРазложитьМодули1СПоПапкамСогласноИерархииМетаданных();
	
	_тест_СтруктураПараметров.КаталогВыгрузки = _тест_СтруктураПараметров.ПутьКGit;
	_тест_СтруктураПараметров.Вставить("ПутьКФайлуКонфигурации", _ПолучитьИмяВременногоФайла(".cf"));
	Тест_ДолженСоздатьПустуюБазуБезШаблона();
	_Тест_СобратьИзИерархииВЛинейнуюСтруктуру();
	_Тест_ЗагрузитьМодулиКонфигурации();
	_Тест_СохранитьКонфигурациюВФайл();
	
		//успешно = СобратьКонфигурацию1СПоПапкамСогласноИерархииМетаданных(_тест_СтруктураПараметров);
		//	юТест.ПроверитьИстину(успешно, "РазложитьМодули1СПоПапкамСогласноИерархииМетаданных");
		//	
	
	лПутьКФайлуКонфигурации = ПолучитьФайлКонфигурацииИзМакета();
	файлЭталон = Новый Файл(лПутьКФайлуКонфигурации);
	ФайлНовый = Новый Файл(_тест_СтруктураПараметров.ПутьКФайлуКонфигурации);
	
	юТест.ПроверитьИстину(ФайлНовый.Существует(), "новый файл конфигурации не существует");
	юТест.ПроверитьИстину(файлЭталон.Существует(), "старый файл конфигурации не существует");
	
	//юТест.ПроверитьИстину(ФайлНовый.Размер() = файлЭталон.Размер(), "цикл разборки и сборки не совпадает с эталонном "+файлЭталон.Размер() + " новый файл "+ФайлНовый.Размер());
	
КонецПроцедуры

Функция ПолучитьФайлКонфигурацииИзМакета(Знач имяМакета = "") 
	Если ИмяМакета = "" Тогда
		ИмяМакета = "ТестовыйФайлКонфигурации";
	КонецЕсли;
	
	ОтносительныйПуть = "testData\" + ИмяМакета + ".cf";
	
	ФайлТестовойКонфигурации = Новый Файл(ОтносительныйПуть);
	_тест_ПутьКФайлуКонфигурации = ФайлТестовойКонфигурации.ПолноеИмя;
	юТест.ПроверитьИстину(ФайлТестовойКонфигурации.Существует(), "не найден файл тестовой конфигурации <"+_тест_ПутьКФайлуКонфигурации+">");
	
	Возврат _тест_ПутьКФайлуКонфигурации;
	
КонецФункции

Процедура УдалитьВременныйФайлКонфигурации()
	// лФайл = Новый Файл(_тест_ПутьКФайлуКонфигурации);
	// Если лФайл.Существует() Тогда
		// Попытка
			// УдалитьФайлы(лФайл);
		// Исключение
		    // //ОписаниеОшибки()
		// КонецПопытки; 
	// КонецЕсли; 
КонецПроцедуры
 

Процедура Тест_ДолженПолучитьТаблицуОписанияВсехИБ() Экспорт
	таблицаОписанияИБ = ЭтотОбъект.ПолучитьТаблицуОписанияВсехИБ();
		юТест.ПроверитьЗаполненность(таблицаОписанияИБ, "таблицаОписанияИБ");
		юТест.ПроверитьЗаполненность(_ТаблицаОписанияВсехИБ, "_ТаблицаОписанияВсехИБ");
	//Ис(таблицаОписанияИБ);
КонецПроцедуры

Процедура Тест_ДолженПолучитьПутьПлатформы1СПоПутиИБ() Экспорт
	ЭтотОбъект.ПолучитьТаблицуОписанияВсехИБ();
	Для каждого строкаИБ Из _ТаблицаОписанияВсехИБ Цикл
		путьИБ = строкаИБ.Путь;
		путьПлатформы1С = ПолучитьПутьПлатформы1СПоПутиИБ(путьИБ);
			юТест.ПроверитьРавенство(путьПлатформы1С, строкаИБ.путьПлатформы1С);
			
		файловыйПуть = строкаИБ.ФайловыйПуть;
		Если ЗначениеЗаполнено(файловыйПуть) Тогда
			путьПлатформы1С = ПолучитьПутьПлатформы1СПоПутиИБ(файловыйПуть);
				юТест.ПроверитьРавенство(путьПлатформы1С, строкаИБ.путьПлатформы1С);
				
			путьПлатформы1С = ПолучитьПутьПлатформы1СПоПутиИБ(файловыйПуть+"\");
				юТест.ПроверитьРавенство(путьПлатформы1С, строкаИБ.путьПлатформы1С);
		КонецЕсли;
	КонецЦикла;
		//юТест.ПроверитьЗаполненность(_ТаблицаОписанияВсехИБ, "_ТаблицаОписанияВсехИБ");
	//Ис(_ТаблицаОписанияВсехИБ);
КонецПроцедуры

Процедура Тест_ДолженПолучитьМаксимальнуюВерсию83() //Экспорт
	путьПлатформ1С_83 = ЭтотОбъект.ПолучитьПутьПлатформы1С_83();
		юТест.ПроверитьРавенство(путьПлатформ1С_83, "C:\Program Files (x86)\1cv8\8.3.3.721\bin\1cv8.exe");
КонецПроцедуры


Процедура Тест_ДолженУбратьОбрамляющиеКавычкиЕслиЕсть() Экспорт
	//ВызватьИсключение "ВРЕМЕННО тест падает - проверка сборки через jenkins";
	
	текст = """"+"W:\Конфигурации\"+"""";
	текстРез = ЭтотОбъект.УбратьОбрамляющиеКавычкиЕслиЕсть(текст);
		юТест.ПроверитьРавенство(текстРез, "W:\Конфигурации\");
		
	текст = "W:\Конфигурации\";
	текстРез = ЭтотОбъект.УбратьОбрамляющиеКавычкиЕслиЕсть(текст);
		юТест.ПроверитьРавенство(текстРез, "W:\Конфигурации\");
КонецПроцедуры

Процедура ОТест_ДолженОпределитьПравильныйПутьКПлатформеПоВерсииПлатформы(параметрыТеста) //Экспорт
	версияПлатформы = параметрыТеста.версияПлатформы; //"8.3.3.721";
	
	правильныйПуть = ЭтотОбъект.ПравильныйПутьКПлатформеПоВерсииПлатформы(версияПлатформы);
		юТест.ПроверитьРавенство(правильныйПуть, параметрыТеста.путь1С, "версияПлатформы <"+версияПлатформы+"> - правильныйПуть, параметрыТеста.путь1С");
КонецПроцедуры

Процедура Тест_ДолженПолучитьФайлВерсийХранилища() Экспорт
	_тест_СтруктураПараметров = Новый Структура;
	_тест_СтруктураПараметров.Вставить("ПутьКФайлуХранилища1С", _ПолучитьПутьКВременномуФайлуХранилища1С());
	
	ПутьКХМЛФайлуВерсийХранилища1С = "";
	ПутьКХМЛФайлуПользователейХранилища1С = "";
	//ПутьКТаблицамИзФайлаХранилища1С = "";
	успешно = ВыгрузитьФайлВерсийИзФайлаХранилища1С(_тест_СтруктураПараметров.ПутьКФайлуХранилища1С, ПутьКХМЛФайлуВерсийХранилища1С, ПутьКХМЛФайлуПользователейХранилища1С);
		юТест.Проверить(успешно, "ВыгрузитьФайлВерсийИзФайлаХранилища1С");
	_тест_СтруктураПараметров.Вставить("ПутьКХМЛФайлуВерсийХранилища1С", ПутьКХМЛФайлуВерсийХранилища1С);
	_тест_СтруктураПараметров.Вставить("ПутьКХМЛФайлуПользователейХранилища1С", ПутьКХМЛФайлуПользователейХранилища1С);
		
	лФайл = Новый Файл(ПутьКХМЛФайлуВерсийХранилища1С);
		юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось получить файл истории хранилища 1С - не существует файл <"+ПутьКХМЛФайлуВерсийХранилища1С + ">");
		
	лФайл = Новый Файл(ПутьКХМЛФайлуПользователейХранилища1С);
		юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось получить файл пользователей хранилища 1С - не существует файл <"+ПутьКХМЛФайлуПользователейХранилища1С + ">");
		
КонецПроцедуры

Функция _ПолучитьПутьКВременномуФайлуХранилища1С()
	лПутьКФайлуХранилища1С = Новый Файл("testData\ТестовыйФайлХранилища1С.1CD");
		
	юТест.ПроверитьИстину(ПроверитьСуществованиеФайлаКаталога(лПутьКФайлуХранилища1С.ПолноеИмя, "Тест_ДолженПолучитьФайлВерсийХранилища - лПутьКФайлуХранилища1С"));
	
	Возврат лПутьКФайлуХранилища1С.ПолноеИмя;
КонецФункции
 
Процедура Тест_ДолженПрочитатьФайлВерсийИзХранилища1С() Экспорт
	Тест_ДолженПолучитьФайлВерсийХранилища();
	
	лПутьФайлаВерсий = _тест_СтруктураПараметров.ПутьКХМЛФайлуВерсийХранилища1С;
	лФайл = Новый Файл(лПутьФайлаВерсий);
		юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось получить файл истории хранилища 1С - не существует файл <"+лПутьФайлаВерсий + ">");
		
	таблицаИсторииХранилища = Неопределено;
	успешно = ПрочитатьФайлВерсий(лПутьФайлаВерсий, таблицаИсторииХранилища);
		юТест.Проверить(успешно, "Тест_ДолженПрочитатьФайлВерсийИзХранилища1С - ПрочитатьФайлВерсий");
		
	//таблицаИсторииХранилища = История.Выгрузить();
		юТест.ПроверитьРавенство(таблицаИсторииХранилища.Количество(), 3, "таблицаИсторииХранилища.Количество()");
	//таблицаИсторииХранилища.Сортировать("НомерВерсии");
	//таблицаИсторииХранилища.ВыбратьСтроку();
КонецПроцедуры

Процедура Тест_ДолженПрочитатьФайлПользователейИзХранилища1С() Экспорт
	Тест_ДолженПолучитьФайлВерсийХранилища();
	
	лПутьФайлаПользователей = _тест_СтруктураПараметров.ПутьКХМЛФайлуПользователейХранилища1С;
	лФайл = Новый Файл(лПутьФайлаПользователей);
		юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось получить файл пользователей хранилища 1С - не существует файл <"+лПутьФайлаПользователей + ">");
		
	таблицаПользователейХранилища = Неопределено;
	успешно = ПрочитатьФайлПользователей(лПутьФайлаПользователей, таблицаПользователейХранилища);
		юТест.Проверить(успешно, "Тест_ДолженПрочитатьФайлПользователейИзХранилища1С - ПрочитатьФайлПользователей");
		
	//таблицаПользователейХранилища = Пользователи.Выгрузить();
		юТест.ПроверитьРавенство(таблицаПользователейХранилища.Количество(), 2, "таблицаПользователейХранилища.Количество()");
	//таблицаПользователейХранилища.Сортировать("НомерВерсии");
	//таблицаПользователейХранилища.ВыбратьСтроку();
КонецПроцедуры

Процедура Тест_ДолженПрочитатьФайлВерсийСИменамиПользователейИзХранилища1С() Экспорт 
	//_тест_СтруктураПараметров = Новый Структура;
	ПутьКФайлуХранилища1С = _ПолучитьПутьКВременномуФайлуХранилища1С();//_тест_СтруктураПараметров.Вставить("ПутьКФайлуХранилища1С", _ПолучитьПутьКВременномуФайлуХранилища1С());
	
	ТаблицаИсторииХранилища = Неопределено;
	успешно = ПолучитьТаблицуВерсийИзФайлаХранилища1С(ПутьКФайлуХранилища1С, "", "", таблицаИсторииХранилища, Неопределено);
		юТест.Проверить(успешно, "Тест_ДолженПрочитатьФайлВерсийСИменамиПользователейИзХранилища1С - ЭтотОбъект.ПолучитьТаблицуВерсийИзФайлаХранилища1С");
		
	//таблицаИсторииХранилища = _тест_СтруктураПараметров.ТаблицаИсторииХранилища;
		юТест.ПроверитьРавенство(таблицаИсторииХранилища.Количество(), 3, "таблицаИсторииХранилища.Количество()");
		
	//таблицаИсторииХранилища.ВыбратьСтроку();
	Для каждого строка Из таблицаИсторииХранилища Цикл
		Если ПустаяСтрока(строка.Автор) Тогда
			ВызватьИсключение "Не найден автор коммита - номер версии <"+строка.НомерВерсии+">, комментарий <"+строка.Комментарий+">";
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура Тест_ТестДолженПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С() Экспорт
	лНомерВерсииХранилища = 2;
	
	//_тест_СтруктураПараметров = Новый Структура;
	//_тест_СтруктураПараметров.Вставить("ПутьКФайлуХранилища1С", _ПолучитьПутьКВременномуФайлуХранилища1С());
	//_тест_СтруктураПараметров.Вставить("ПутьКХранилищу1C", "tcp://ws-msk-a2354:3542/1C2Git");
	//_тест_СтруктураПараметров.Вставить("НомерВерсииХранилища", лНомерВерсииХранилища);
	//
	//_тест_СтруктураПараметров.Вставить("Пользователь", "");
	//_тест_СтруктураПараметров.Вставить("Пароль", "");
	//_тест_СтруктураПараметров.Вставить("ПользовательХранилища", "Отладка");
	//_тест_СтруктураПараметров.Вставить("ПарольХранилища", "");
	//
	//_тест_СтруктураПараметров.Вставить("ПутьКБазе", "File=""W:\Конфигурации\Связной\1C2Git_Отладка""");
	//_тест_СтруктураПараметров.Вставить("версияПлатформыДляБазы", ""); //8.3
	//
	//	//_тест_СтруктураПараметров.Вставить("ПутьКХранилищу1C", "tcp://repository17/1CUnit\");
	//	//_тест_СтруктураПараметров.Вставить("НомерВерсииХранилища", лНомерВерсииХранилища);
	//	//
	//	//_тест_СтруктураПараметров.Вставить("Пользователь", "Администратор");
	//	//_тест_СтруктураПараметров.Вставить("Пароль", "");
	//	//_тест_СтруктураПараметров.Вставить("ПользовательХранилища", "aayuhanov");
	//	//_тест_СтруктураПараметров.Вставить("ПарольХранилища", "1");
	//	//
	//	//_тест_СтруктураПараметров.Вставить("ПутьКБазе", "File=""W:\Конфигурации\Разработка\1CUnit\ТестоваяБаза""");
	//	
	//Параметры = _тест_СтруктураПараметров;
	
	П = ПараметрыПоУмолчанию_1C2Git();
	П.Вставить("НомерВерсииХранилища", лНомерВерсииХранилища);
	
	ПутьКФайлуКонфигурации = "";
	успешно = ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С(П.ПутьКБазе, П.версияПлатформыДляБазы, П.Пользователь, П.Пароль, П.ПутьКХранилищу1C, 
		П.ПользовательХранилища, П.ПарольХранилища, П.ПутьКФайлуХранилища1С, П.НомерВерсииХранилища, ПутьКФайлуКонфигурации); //ЭтотОбъект.
		
		юТест.Проверить(успешно, "ПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С - Тест_ТестДолженПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С");
		юТест.Проверить(ПроверитьСуществованиеФайлаКаталога(ПутьКФайлуКонфигурации), "ПроверитьСуществованиеФайлаКаталога(ПутьКФайлуКонфигурации) - Тест_ТестДолженПоНомеруВерсииСохранитьКонфигурациюИзХранилища1С");
КонецПроцедуры

Функция ПараметрыПоУмолчанию_1C2Git()
	П = Новый Структура;
	П.Вставить("ПутьКФайлуХранилища1С", _ПолучитьПутьКВременномуФайлуХранилища1С());
	П.Вставить("ПутьКХранилищу1C", "tcp://ws-msk-a2354:3542/1C2Git");
	
	П.Вставить("Пользователь", "");
	П.Вставить("Пароль", "");
	П.Вставить("ПользовательХранилища", "unit");
	П.Вставить("ПарольХранилища", "");
	П.Вставить("НомерВерсииХранилища", 0);
	
	П.Вставить("ПутьКБазе", "File=""F:\1C2Git_Отладка""");//"File=""W:\Конфигурации\Связной\1C2Git_Отладка""");
	П.Вставить("версияПлатформыДляБазы", "8.3");
	
	П.Вставить("КаталогВыгрузки", ПолучитьВременноеИмяКаталога());
	П.Вставить("КаталогВыгрузкиВсехМодулей83", ПолучитьВременноеИмяКаталога());
	
		//_тест_СтруктураПараметров.Вставить("ПутьКХранилищу1C", "tcp://repository17/1CUnit\");
		//_тест_СтруктураПараметров.Вставить("НомерВерсииХранилища", лНомерВерсииХранилища);
		//
		//_тест_СтруктураПараметров.Вставить("Пользователь", "Администратор");
		//_тест_СтруктураПараметров.Вставить("Пароль", "");
		//_тест_СтруктураПараметров.Вставить("ПользовательХранилища", "aayuhanov");
		//_тест_СтруктураПараметров.Вставить("ПарольХранилища", "1");
		//
		//_тест_СтруктураПараметров.Вставить("ПутьКБазе", "File=""W:\Конфигурации\Разработка\1CUnit\ТестоваяБаза""");
	
	_тест_СтруктураПараметров = П;
	Возврат П;
КонецФункции
 
Процедура Тест_ТестДолженПоНомеруВерсииРазобратьКонфигурациюИзХранилища1С() Экспорт
	лНомерВерсииХранилища = 2;
	
	П = ПараметрыПоУмолчанию_1C2Git();
	П.Вставить("НомерВерсииХранилища", лНомерВерсииХранилища);
	
	резПутьКФайлуКонфигурации = "";
	успешно = ПоНомеруВерсииРазобратьКонфигурациюИзХранилища1С(П.ПутьКБазе, П.версияПлатформыДляБазы, П.Пользователь, П.Пароль, П.ПутьКХранилищу1C, 
		П.ПользовательХранилища, П.ПарольХранилища, П.ПутьКФайлуХранилища1С, П.НомерВерсииХранилища, П.КаталогВыгрузкиВсехМодулей83, П.КаталогВыгрузки, 
		резПутьКФайлуКонфигурации);
		
		юТест.Проверить(успешно, "вызов ПоНомеруВерсииРазобратьКонфигурациюИзХранилища1С - Тест_ТестДолженПоНомеруВерсииРазобратьКонфигурациюИзХранилища1С");
		
	ПутьКGit = П.КаталогВыгрузки;
	
		лФайл = Новый Файл(ПутьКGit + "\renames.txt");
			юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось разложить модули 1С по иерархии - не существует файл <"+лФайл.ПолноеИмя+">");
			
		МассивФайлов = НайтиФайлы(ПутьКGit,"*.*");
			юТест.ПроверитьИстину(МассивФайлов.Количество() > 0, "в каталоге разложения модулей 1С <"+П.КаталогВыгрузки+"> должны быть файлы");
КонецПроцедуры

Процедура Тест_ДолженРазложитьМодули1СпоНомеруВерсииХранилища1С() Экспорт 
	П = ПараметрыПоУмолчанию_1C2Git();
	
	//Тест_ДолженСоздатьПустуюБазуПоФайлуКонфигурации();		
	//Тест_ДолженВыгрузитьМодули();
	
	лПутьКаталогаВыгрузкиДанных = П.КаталогВыгрузки;
		//лПутьКаталогаВыгрузкиДанных = ПолучитьВременноеИмяКаталога(); //СтрЗаменить(_ПолучитьИмяВременногоФайла("сtr"), ".сtr", "");
		//П.Вставить("КаталогВыгрузки", лПутьКаталогаВыгрузкиДанных);
	
	//П = _тест_СтруктураПараметров;
	
	успешно = РазложитьМодули1СпоНомеруВерсииХранилища1С(П.ПутьКБазе, П.ВерсияПлатформыДляБазы, П.Пользователь, П.Пароль, П.ПутьКХранилищу1C, 
		П.ПользовательХранилища, П.ПарольХранилища, П.ПутьКФайлуХранилища1С, П.НомерВерсииХранилища, П.КаталогВыгрузки, П.КаталогВыгрузкиВсехМодулей83, 
		"");
	
	//успешно = РазложитьМодули1СпоНомеруВерсииХранилища1С(_тест_СтруктураПараметров.КаталогВыгрузкиВсехМодулей83, лПутьКаталогаВыгрузкиДанных);
	////	ВывестиСообщение("Не удалось выполнить копирование файлов");
	////	Возврат Ложь;
	////КонецЕсли; 
	
	//успешно = РазложитьМодули1СПоПапкамСогласноИерархииМетаданных(_тест_СтруктураПараметров);
		юТест.ПроверитьИстину(успешно, "РазложитьМодули1СПоПапкамСогласноИерархииМетаданных");
	//_тест_СтруктураПараметров.Вставить("ПутьКGit", лПутьКаталогаВыгрузкиДанных);
		
	лФайл = Новый Файл(лПутьКаталогаВыгрузкиДанных + "\renames.txt");
		юТест.ПроверитьИстину(лФайл.Существует(), "Не удалось разложим модули 1С по иерархии - не существует файл <"+лФайл.ПолноеИмя+">");
		
	МассивФайлов = НайтиФайлы(лПутьКаталогаВыгрузкиДанных,"*.*");
		юТест.ПроверитьИстину(МассивФайлов.Количество() > 0, "в каталоге разложения модулей 1С <"+лПутьКаталогаВыгрузкиДанных+"> должны быть файлы");
КонецПроцедуры
	
Процедура ТестДолжен_СинхронизироватьХранилищеКонфигурацийСГит() Экспорт
	П = ПараметрыПоУмолчанию_1C2Git();
	
	//РабочийКаталог = "d:\tmp\tmp_repo\";	
	//П.КаталогВыгрузки = "d:\tmp\repo\";
	
	лПутьКаталогаВыгрузкиДанных = П.КаталогВыгрузки;	
	СоздатьКаталог(лПутьКаталогаВыгрузкиДанных);	

	
	ИмяФайлаВыполнения = _ПолучитьИмяВременногоФайла("bat");
	ФайлДляВыполнения = Новый ЗаписьТекста(ИмяФайлаВыполнения, "cp866");
	ФайлДляВыполнения.ЗаписатьСтроку("cd /d """ + лПутьКаталогаВыгрузкиДанных+"""");	
	ФайлДляВыполнения.ЗаписатьСтроку("git init");
	ФайлДляВыполнения.ЗаписатьСтроку("exit /b %ERRORLEVEL%");
	ФайлДляВыполнения.Закрыть();
	
	РезультатИнициализацииГитЧисло = ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(ИмяФайлаВыполнения);
	юТест.ПроверитьИстину(РезультатИнициализацииГитЧисло=0, "Инициализация git-хранилища в каталоге: "+лПутьКаталогаВыгрузкиДанных);
	
	//Создать файл авторов:
	// ФайлАвторов = Новый ТекстовыйДокумент;
	// ФайлАвторов.ЗаписатьСтроку("d369fb67-6606-8f43-568d-246066c94846;Администратор <admin@localhost>");
	// ФайлАвторов.ЗаписатьСтроку("60248d56-c966-4648-8f43-6606d369fb67;Администратор <admin@localhost>");
	// ФайлАвторов.ЗаписатьСтроку("96159ec1-3817-a6c0-f92a-9000350d8b4c;Отладка <debug@localhost>");
	// ФайлАвторов.ЗаписатьСтроку("00902af9-0d35-4c8b-a6c0-381796159ec1;Отладка <debug@localhost>");
	// ФайлАвторов.Записать(лПутьКаталогаВыгрузкиДанных+"\AUTHORS", КодировкаТекста.UTF8);
	
	РезультатСинхронизации = СинхронизироватьХранилищеКонфигурацийСГит(П);
	юТест.ПроверитьИстину(РезультатСинхронизации, "СинхронизироватьХранилищеКонфигурацийСГит");
	
	ИмяФайлаЛогаГит = _ПолучитьИмяВременногоФайла("txt");
	ИмяФайлКомандыПроверкиХранилища = _ПолучитьИмяВременногоФайла("bat");
	ФайлКомандыПроверкиХранилища = Новый ЗаписьТекста;
	ФайлКомандыПроверкиХранилища.Открыть(ИмяФайлКомандыПроверкиХранилища, "cp866");
	ФайлКомандыПроверкиХранилища.ЗаписатьСтроку("cd /d """ + лПутьКаталогаВыгрузкиДанных+"""");	
	ФайлКомандыПроверкиХранилища.ЗаписатьСтроку("git log --pretty=oneline >"""+ИмяФайлаЛогаГит+"""");
	ФайлКомандыПроверкиХранилища.Закрыть();
	
	РезультатВыводаЛогаГитЧисло = ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(ИмяФайлКомандыПроверкиХранилища);
	юТест.ПроверитьИстину(РезультатВыводаЛогаГитЧисло=0, "Получение краткого лога хранилища git");
	
	ЛогГит = Новый ЧтениеТекста;
	ЛогГит.Открыть(ИмяФайлаЛогаГит);
	КоличествоКоммитов = 0;
	Пока ЛогГит.ПрочитатьСтроку() <> Неопределено Цикл
		КоличествоКоммитов = КоличествоКоммитов + 1;
	КонецЦикла;
	ЛогГит.Закрыть();
	юТест.ПроверитьРавенство(КоличествоКоммитов, 3, "Количество коммитов в git-хранилище");
	
КонецПроцедуры
	

_тестируем = Ложь;
юТест = Неопределено;

// ======================= ======================= ======================= ======================= 
//
// КОНЕЦ БЛОКА ЮНИТ-ТЕСТОВ
//
//} ======================= ======================= ======================= =======================

WshShell = Новый COMОбъект("WScript.Shell");

_ТаблицаОписанияВсехИБ = Неопределено;

// типизированные реквизиты обработки (удалить)
БылаИнициализация = Ложь;
ВключенРежимОтладки = Ложь;
ВыводитьСообщенияВЖурналРегистрации = Ложь;